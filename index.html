<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Simple Audio Looper</title>
		<style>
			:root {
				--bg: #0f1220;
				--panel: #171a2a;
				--accent: #5eead4;
				--text: #e6e8f1;
				--muted: #9aa0b4;
				--bar: #2a2f48;
				--barFill: #5eead4;
				--handle: #a8ffcb;
			}
			* {
				box-sizing: border-box;
			}
			body {
				margin: 0;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial,
					sans-serif;
				background: radial-gradient(
						1200px 600px at 50% -10%,
						#1d2140,
						#0b0e1a 70%
					),
					var(--bg);
				color: var(--text);
				min-height: 100dvh;
				display: grid;
				place-items: start center;
			}
			.wrap {
				width: min(1120px, 96vw);
				padding: 28px 16px 48px;
			}
			h1 {
				margin: 6px 0 18px;
				font-weight: 700;
				letter-spacing: 0.2px;
			}
			.panel {
				background: linear-gradient(180deg, #1a1e33, #14182a);
				border: 1px solid #242a42;
				border-radius: 16px;
				padding: 18px;
				box-shadow: 0 8px 28px rgba(0, 0, 0, 0.4);
			}
			.controls {
				display: grid;
				grid-template-columns: repeat(4, minmax(230px, 1fr));
				gap: 12px;
				align-items: center;
			}
			.btn {
				appearance: none;
				border: 0;
				border-radius: 12px;
				padding: 16px 18px;
				font-size: 18px;
				font-weight: 700;
				cursor: pointer;
				transition: transform 0.04s ease, box-shadow 0.2s ease,
					background 0.2s ease, opacity 0.2s ease;
				box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
				color: #0a1022;
				white-space: nowrap;
			}
			.btn:active {
				transform: translateY(1px);
			}
			.btn[disabled] {
				opacity: 0.5;
				cursor: not-allowed;
			}
			.btn.record {
				background: linear-gradient(180deg, #ff7a7a, #ff4747);
				color: #200;
			}
			.btn.stop {
				background: linear-gradient(180deg, #7af7d6, #3be7c3);
			}
			.btn.halt {
				background: linear-gradient(180deg, #9cc2ff, #6aa0ff);
			}
			.btn.dl {
				background: linear-gradient(180deg, #ffd28b, #ffc266);
			}
			.status {
				margin-top: 10px;
				color: var(--muted);
				font-size: 14px;
				min-height: 20px;
			}

			.samples {
				margin-top: 18px;
				display: grid;
				gap: 10px;
			}
			.sample {
				display: grid;
				grid-template-columns: 1fr minmax(140px, 28%) 42px 42px 42px 42px;
				gap: 10px;
				align-items: center;
				background: var(--panel);
				border: 1px solid #252a40;
				border-radius: 12px;
				padding: 10px 12px;
			}
			.sample .name {
				font-weight: 600;
				color: #dbe2ff;
				font-size: 14px;
			}
			.sample .info {
				color: var(--muted);
				font-size: 12px;
				margin-bottom: 6px;
			}

			/* Progress bar + handle */
			.progWrap {
				display: grid;
				gap: 6px;
			}
			.prog {
				position: relative;
				height: 10px;
				background: var(--bar);
				border-radius: 6px;
				overflow: hidden;
				user-select: none;
				touch-action: none;
			}
			.prog .fill {
				position: absolute;
				inset: 0 auto 0 0;
				width: 0%;
				background: var(--barFill);
				opacity: 0.9;
			}
			.prog .handle {
				position: absolute;
				top: -5px;
				width: 12px;
				height: 20px;
				background: var(--handle);
				border-radius: 6px;
				box-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
				cursor: ew-resize;
				transform: translateX(-50%);
			}
			.prog .handle:hover {
				filter: brightness(1.05);
			}

			.vcol {
				display: grid;
				gap: 6px;
			}
			input[type='range'] {
				width: 100%;
				accent-color: var(--accent);
			}

			.del,
			.mute,
			.solo,
			.play {
				border: 0;
				background: #2a2f48;
				color: #d7e3ff;
				border-radius: 10px;
				width: 42px;
				height: 42px;
				font-size: 18px;
				cursor: pointer;
				transition: background 0.2s ease, transform 0.04s ease;
			}
			.del:hover,
			.mute:hover,
			.solo:hover,
			.play:hover {
				background: #353b5a;
			}
			.del {
				color: #ffb4b4;
			}
			.del:active,
			.mute:active,
			.solo:active,
			.play:active {
				transform: translateY(1px);
			}
			.mute.active {
				color: #ffd28b;
				background: #3b415f;
			}
			.solo.active {
				color: #a8ffcb;
				background: #3b415f;
			}

			@media (max-width: 600px) {
				.controls {
					grid-template-columns: 1fr;
				}
				.sample {
					grid-template-columns: 1fr 1fr 42px 42px 42px 42px;
				}
			}

			/* Oscilloscope */
			.scope {
				display: none;
				margin-top: 10px;
				background: #0a0d18;
				border: 1px solid #252a40;
				border-radius: 12px;
				width: 100%;
				height: 140px;
			}
			.scope.active {
				display: block;
			}

			.footer {
				margin-top: 18px;
				color: var(--muted);
				font-size: 12px;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<h1>Simple Audio Looper</h1>
			<div class="panel">
				<div class="controls">
					<button id="recToggleBtn" class="btn record" aria-pressed="false">
						● Record
					</button>
					<button id="haltBtn" class="btn halt" disabled>
						⏹ Stop Playback
					</button>
					<button id="mixRecBtn" class="btn record" aria-pressed="false">
						⏺ Record Mix
					</button>
					<button id="mixDlBtn" class="btn dl" disabled>⬇ Download WAV</button>
				</div>
				<div id="status" class="status">Ready.</div>
				<canvas id="scope" class="scope" aria-hidden="true"></canvas>
				<div id="samples" class="samples" aria-live="polite"></div>
			</div>
			<div class="footer">
				Space: Mic Record • Shift+Space: Stop/Resume • Tip: adjust levels with
				the sliders; click ✕ to remove a loop.
			</div>
		</div>

		<script>
			'use strict';

			/* ===== Core audio state ===== */
			let audioCtx = null,
				masterGain = null;
			let mediaStream = null,
				mediaRecorder = null,
				recordingChunks = [];
			let loopCounter = 0;

			/* Oscilloscope */
			let micSource = null,
				analyser = null,
				scopeRAF = null,
				scopeData = null,
				isDrawing = false;

			/* Loop grid + progress bars */
			let masterLenSec = null; // base grid (first track duration)
			let transportStartTime = null; // grid start
			let isPlaybackSuspended = false; // our explicit toggle state
			let barCycleSec = 0; // longest track for bar width scaling

			/* Mix recorder */
			let mixDest = null,
				mixMR = null,
				mixChunks = [],
				mixWavUrl = null,
				mixRecording = false;

			/* UI tick */
			let uiRAF = null; // requestAnimationFrame id
			let frozenNow = 0; // last time when frozen

			/** Each loop: { id, buffer, source, gainNode, el, userGain, muted, solo, resyncTimer?, offsetSec, bar:{wrap,fill,handle} } */
			const loops = new Map();

			/* UI nodes */
			const recToggleBtn = document.getElementById('recToggleBtn');
			const haltBtn = document.getElementById('haltBtn');
			const mixRecBtn = document.getElementById('mixRecBtn');
			const mixDlBtn = document.getElementById('mixDlBtn');
			const statusEl = document.getElementById('status');
			const samplesEl = document.getElementById('samples');
			const scopeCanvas = document.getElementById('scope');
			const scopeCtx = scopeCanvas.getContext('2d');

			function setStatus(m) {
				statusEl.textContent = m;
			}

			/* ===== Boot audio ===== */
			function ensureAudio() {
				if (!audioCtx) {
					audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					masterGain = audioCtx.createGain();
					masterGain.gain.value = 1.0;
					masterGain.connect(audioCtx.destination);

					audioCtx.addEventListener('statechange', () => {
						// Keep button label honest and bars frozen while not running
						if (audioCtx.state === 'running') {
							isPlaybackSuspended = false;
							updateHaltButtonUI();
						} else if (audioCtx.state === 'suspended') {
							isPlaybackSuspended = true;
							frozenNow = audioCtx.currentTime;
							updateHaltButtonUI();
						}
					});

					haltBtn.disabled = false;
					updateHaltButtonUI();
				}
				ensureMixStream();
				ensureUiTicker();
			}

			async function getMicStream() {
				if (mediaStream && mediaStream.active) return mediaStream;
				try {
					mediaStream = await navigator.mediaDevices.getUserMedia({
						audio: {
							echoCancellation: false,
							noiseSuppression: false,
							autoGainControl: false,
						},
						video: false,
					});
					return mediaStream;
				} catch (err) {
					console.error(err);
					setStatus(
						'Mic access failed. Please allow permission and try again.'
					);
					throw err;
				}
			}

			function pickMimeType() {
				const c = [
					'audio/webm;codecs=opus',
					'audio/ogg;codecs=opus',
					'audio/webm',
					'audio/ogg',
				];
				for (const t of c) {
					if (
						window.MediaRecorder &&
						MediaRecorder.isTypeSupported &&
						MediaRecorder.isTypeSupported(t)
					)
						return t;
				}
				return '';
			}

			/* ===== Scope ===== */
			function ensureAnalyser(stream) {
				if (!audioCtx) return;
				if (!micSource) {
					micSource = audioCtx.createMediaStreamSource(stream);
					analyser = audioCtx.createAnalyser();
					analyser.fftSize = 2048;
					analyser.smoothingTimeConstant = 0.85;
					micSource.connect(analyser);
					scopeData = new Uint8Array(analyser.frequencyBinCount);
				}
			}
			function startScope() {
				if (!analyser) return;
				isDrawing = true;
				scopeCanvas.classList.add('active');
				scopeCanvas.setAttribute('aria-hidden', 'false');
				drawScope();
			}
			function stopScope() {
				isDrawing = false;
				if (scopeRAF) {
					cancelAnimationFrame(scopeRAF);
					scopeRAF = null;
				}
				try {
					scopeCtx.clearRect(0, 0, scopeCanvas.width, scopeCanvas.height);
				} catch (_) {}
				scopeCanvas.classList.remove('active');
				scopeCanvas.setAttribute('aria-hidden', 'true');
			}
			function fmtTime(secs) {
				secs = Math.max(0, secs || 0);
				const m = Math.floor(secs / 60),
					s = Math.floor(secs % 60),
					d = Math.floor((secs - Math.floor(secs)) * 10);
				return `${m}:${String(s).padStart(2, '0')}.${d}`;
			}
			function drawScope() {
				if (!isDrawing || !analyser) return;
				const dpr = window.devicePixelRatio || 1,
					cssW = scopeCanvas.clientWidth || 600,
					cssH = scopeCanvas.clientHeight || 140;
				if (
					scopeCanvas.width !== Math.floor(cssW * dpr) ||
					scopeCanvas.height !== Math.floor(cssH * dpr)
				) {
					scopeCanvas.width = Math.floor(cssW * dpr);
					scopeCanvas.height = Math.floor(cssH * dpr);
					scopeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
				}
				analyser.getByteTimeDomainData(scopeData);
				scopeCtx.clearRect(0, 0, cssW, cssH);
				scopeCtx.beginPath();
				const mid = cssH / 2,
					step = cssW / scopeData.length;
				for (let i = 0; i < scopeData.length; i++) {
					const v = (scopeData[i] - 128) / 128;
					const x = i * step,
						y = mid + v * (cssH * 0.45);
					if (i === 0) scopeCtx.moveTo(x, y);
					else scopeCtx.lineTo(x, y);
				}
				scopeCtx.lineWidth = 2;
				scopeCtx.strokeStyle = '#79ffe1';
				scopeCtx.stroke();

				// elapsed while mic recording
				if (
					mediaRecorder &&
					mediaRecorder.state === 'recording' &&
					audioCtx &&
					transportStartTime != null
				) {
					const t = fmtTime(audioCtx.currentTime - (audioCtx.baseLatency || 0));
					const label = `REC ${t}`,
						pad = 6,
						h = 22;
					scopeCtx.font =
						'13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
					const w = Math.ceil(scopeCtx.measureText(label).width) + pad * 2;
					const x = cssW - w - 8,
						y = 8;
					scopeCtx.fillStyle = 'rgba(0,0,0,0.45)';
					scopeCtx.fillRect(x, y, w, h);
					scopeCtx.fillStyle = '#e6e8f1';
					scopeCtx.fillText(label, x + pad, y + 15);
				}
				scopeRAF = requestAnimationFrame(drawScope);
			}
			window.addEventListener('resize', () => {
				if (scopeCanvas.classList.contains('active')) drawScope();
			});

			/* ===== Mic record toggle ===== */
			function updateRecToggleUI(recording) {
				if (recording) {
					recToggleBtn.classList.remove('record');
					recToggleBtn.classList.add('stop');
					recToggleBtn.textContent = '■ Stop';
					recToggleBtn.setAttribute('aria-pressed', 'true');
				} else {
					recToggleBtn.classList.remove('stop');
					recToggleBtn.classList.add('record');
					recToggleBtn.textContent = '● Record';
					recToggleBtn.setAttribute('aria-pressed', 'false');
				}
			}
			async function startRecording() {
				ensureAudio();
				await audioCtx.resume();
				const stream = await getMicStream();
				ensureAnalyser(stream);
				startScope();

				const options = {},
					mt = pickMimeType();
				if (mt) options.mimeType = mt;
				try {
					mediaRecorder = new MediaRecorder(stream, options);
				} catch (e) {
					console.error(e);
					setStatus('Recording is not supported in this browser.');
					return;
				}

				recordingChunks = [];
				mediaRecorder.ondataavailable = (e) => {
					if (e.data && e.data.size > 0) recordingChunks.push(e.data);
				};
				mediaRecorder.onstop = handleRecordingStop;
				mediaRecorder.start();

				updateRecToggleUI(true);
				setStatus('Recording… Press again to stop.');
			}
			async function stopRecording() {
				if (mediaRecorder && mediaRecorder.state === 'recording') {
					stopScope();
					mediaRecorder.stop();
					setStatus('Processing…');
				}
			}
			async function toggleRecording() {
				if (mediaRecorder && mediaRecorder.state === 'recording')
					await stopRecording();
				else await startRecording();
			}
			function decodeSafely(ab) {
				const copy = ab.slice(0);
				return new Promise((res, rej) =>
					audioCtx.decodeAudioData(copy, res, rej)
				);
			}

			/* ===== Solo/Mute gain ===== */
			function anySoloActive() {
				for (const [, it] of loops) {
					if (it.solo) return true;
				}
				return false;
			}
			function effectiveGain(userGain, muted, solo, anySolo) {
				if (anySolo) return solo ? userGain : 0;
				return muted ? 0 : userGain;
			}
			function applyGain(item) {
				if (!item || !item.gainNode) return;
				const ug = item.userGain ?? 1;
				item.gainNode.gain.value = effectiveGain(
					ug,
					!!item.muted,
					!!item.solo,
					anySoloActive()
				);
			}
			function updateAllGains() {
				for (const [, it] of loops) {
					applyGain(it);
				}
			}

			/* ===== Grid helpers ===== */
			function padToMultiple(buffer, baseSec, ctx = audioCtx) {
				const rate = buffer.sampleRate,
					base = Math.max(1, Math.round(baseSec * rate)),
					cur = buffer.length;
				const multiple = Math.max(1, Math.ceil(cur / base)),
					newLen = multiple * base;
				if (newLen === cur) return buffer;
				const out = ctx.createBuffer(buffer.numberOfChannels, newLen, rate);
				for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
					out.getChannelData(ch).set(buffer.getChannelData(ch));
				}
				return out;
			}
			function nextGridTime(now) {
				if (transportStartTime == null || masterLenSec == null)
					return now + 0.05;
				const lookahead = 0.05,
					elapsed = now - transportStartTime;
				if (elapsed < -0.001) return transportStartTime + 0.05;
				const cycles = Math.ceil((elapsed + lookahead) / masterLenSec);
				return transportStartTime + cycles * masterLenSec;
			}
			async function resampleToContext(buffer, targetRate) {
				if (!buffer || buffer.sampleRate === targetRate) return buffer;
				const off = new OfflineAudioContext(
					buffer.numberOfChannels,
					Math.ceil(buffer.duration * targetRate),
					targetRate
				);
				const src = off.createBufferSource();
				src.buffer = buffer;
				src.connect(off.destination);
				src.start(0);
				return await off.startRendering();
			}

			/* ===== Phase + restart logic =====
   We define offsetSec so that buffer phase 0 hits when t == transportStartTime + offsetSec.
   The handle sets offsetSec directly along the global (longest) bar; we mod by the track's duration. */
			function phaseOffsetAtTime(item, t) {
				if (!transportStartTime || !item.buffer) return 0;
				const dur = item.buffer.duration || 1e-6;
				const off = (((item.offsetSec || 0) % dur) + dur) % dur;
				const raw = (t - transportStartTime - off) % dur; // if t == start+off => 0
				return (raw + dur) % dur;
			}

			function replaceSource(item, startTime, offset) {
				const s = audioCtx.createBufferSource();
				s.buffer = item.buffer;
				s.loop = true;
				s.connect(item.gainNode);
				s.start(startTime, offset);
				item.source = s;
			}

			function restartFromOffset(item) {
				if (!item || !item.buffer || !audioCtx) return;
				if (item.resyncTimer) {
					clearTimeout(item.resyncTimer);
					item.resyncTimer = null;
				}
				const now = audioCtx.currentTime,
					boundary = nextGridTime(now);
				const offNow = phaseOffsetAtTime(item, now);
				const offBoundary = phaseOffsetAtTime(item, boundary);

				try {
					item.source.stop();
				} catch (_) {}
				replaceSource(item, now, offNow);

				const msUntil = Math.max(
					0,
					Math.round((boundary - audioCtx.currentTime) * 1000)
				);
				item.resyncTimer = setTimeout(() => {
					const prev = item.source;
					replaceSource(item, boundary, offBoundary);
					try {
						prev.stop(boundary);
					} catch (_) {}
					item.resyncTimer = null;
				}, Math.max(0, msUntil - 20));
			}

			function playRestart(id) {
				const item = loops.get(id);
				if (!item || !audioCtx) return;
				if (item.resyncTimer) {
					clearTimeout(item.resyncTimer);
					item.resyncTimer = null;
				}
				const now = audioCtx.currentTime,
					boundary = nextGridTime(now);
				const offNow = phaseOffsetAtTime(item, now);
				const offBoundary = phaseOffsetAtTime(item, boundary);

				try {
					item.source.stop();
				} catch (_) {}
				replaceSource(item, now, offNow);

				const msUntil = Math.max(
					0,
					Math.round((boundary - audioCtx.currentTime) * 1000)
				);
				item.resyncTimer = setTimeout(() => {
					const prev = item.source;
					replaceSource(item, boundary, offBoundary);
					try {
						prev.stop(boundary);
					} catch (_) {}
					item.resyncTimer = null;
				}, Math.max(0, msUntil - 20));
			}

			/* ===== Loop creation ===== */
			function startLoopNode(buffer, when) {
				const id = `loop-${++loopCounter}`;
				const source = audioCtx.createBufferSource();
				source.buffer = buffer;
				source.loop = true;
				const gainNode = audioCtx.createGain();
				gainNode.gain.value = 1.0;
				source.connect(gainNode).connect(masterGain);
				source.start(when);

				const el = renderSampleItem({ id, duration: buffer.duration });
				return {
					id,
					buffer,
					source,
					gainNode,
					el,
					userGain: 1.0,
					muted: false,
					solo: false,
					resyncTimer: null,
					offsetSec: 0,
				};
			}
			function recomputeBarCycle() {
				let m = 0;
				for (const [, it] of loops) {
					m = Math.max(m, it.buffer ? it.buffer.duration : 0);
				}
				barCycleSec = m || 0;
				for (const [, it] of loops) {
					updateHandleUI(it);
				}
			}
			async function addLoop(buffer) {
				buffer = await resampleToContext(buffer, audioCtx.sampleRate);
				if (masterLenSec == null) {
					masterLenSec = buffer.duration;
					buffer = padToMultiple(buffer, masterLenSec);
					transportStartTime = audioCtx.currentTime + 0.2;
					const node = startLoopNode(buffer, transportStartTime);
					loops.set(node.id, node);
					setStatus('First loop set as master. New loops will align to it.');
				} else {
					buffer = padToMultiple(buffer, masterLenSec);
					const startAt = nextGridTime(audioCtx.currentTime);
					const node = startLoopNode(buffer, startAt);
					loops.set(node.id, node);
					const eta = Math.max(
						0,
						Math.round((startAt - audioCtx.currentTime) * 1000)
					);
					setStatus(`Loop added; starts at next boundary in ~${eta} ms.`);
				}
				recomputeBarCycle();
				updateSoloButtonsUI();
				updateAllGains();
			}
			async function handleRecordingStop() {
				try {
					const blob = new Blob(recordingChunks, {
						type: mediaRecorder.mimeType || 'audio/webm',
					});
					const ab = await blob.arrayBuffer();
					const buffer = await decodeSafely(ab);
					await addLoop(buffer);
				} catch (err) {
					console.error(err);
					setStatus('Could not decode audio. Please try another recording.');
				} finally {
					updateRecToggleUI(false);
				}
			}

			/* ===== Row UI (with progress bar + handle) ===== */
			function renderSampleItem({ id, duration }) {
				const row = document.createElement('div');
				row.className = 'sample';
				row.id = id;

				const name = document.createElement('div');
				name.className = 'name';
				name.textContent = `Sample ${id.split('-')[1]}`;
				const info = document.createElement('div');
				info.className = 'info';
				info.textContent = `${duration.toFixed(2)} s loop`;

				// bar
				const progWrap = document.createElement('div');
				progWrap.className = 'progWrap';
				const prog = document.createElement('div');
				prog.className = 'prog';
				prog.setAttribute('aria-label', 'Time shift / progress');
				prog.tabIndex = 0;
				const fill = document.createElement('div');
				fill.className = 'fill';
				const handle = document.createElement('div');
				handle.className = 'handle';
				prog.appendChild(fill);
				prog.appendChild(handle);
				progWrap.appendChild(prog);

				const labelCol = document.createElement('div');
				labelCol.appendChild(name);
				labelCol.appendChild(info);
				labelCol.appendChild(progWrap);

				const vcol = document.createElement('div');
				vcol.className = 'vcol';
				const slider = document.createElement('input');
				slider.type = 'range';
				slider.min = '0';
				slider.max = '100';
				slider.value = '100';
				slider.setAttribute('aria-label', 'Level');
				vcol.appendChild(slider);

				const play = document.createElement('button');
				play.className = 'play';
				play.title = 'Play now';
				play.setAttribute('aria-label', 'Play now');
				play.textContent = '▶';
				const mute = document.createElement('button');
				mute.className = 'mute';
				mute.title = 'Mute/unmute';
				mute.setAttribute('aria-pressed', 'false');
				mute.textContent = '🔈';
				const solo = document.createElement('button');
				solo.className = 'solo';
				solo.title = 'Solo';
				solo.setAttribute('aria-pressed', 'false');
				solo.textContent = '🎧';
				const del = document.createElement('button');
				del.className = 'del';
				del.title = 'Delete loop';
				del.setAttribute('aria-label', 'Delete loop');
				del.textContent = '✕';

				row.appendChild(labelCol);
				row.appendChild(vcol);
				row.appendChild(play);
				row.appendChild(mute);
				row.appendChild(solo);
				row.appendChild(del);
				samplesEl.appendChild(row);

				slider.addEventListener('input', () => {
					const it = loops.get(id);
					if (it) {
						it.userGain = parseInt(slider.value, 10) / 100;
						applyGain(it);
					}
				});
				play.addEventListener('click', () => playRestart(id));
				mute.addEventListener('click', () => {
					const it = loops.get(id);
					if (!it) return;
					it.muted = !it.muted;
					mute.classList.toggle('active', it.muted);
					mute.setAttribute('aria-pressed', String(it.muted));
					mute.textContent = it.muted ? '🔇' : '🔈';
					updateAllGains();
				});
				solo.addEventListener('click', () => toggleSolo(id));
				del.addEventListener('click', () => removeLoop(id));

				// dragging: set offsetSec along global bar, then restart from that phase
				let dragging = false;
				function pxToOffsetSec(clientX) {
					if (!barCycleSec) return 0;
					const r = prog.getBoundingClientRect();
					const frac = Math.min(
						1,
						Math.max(0, (clientX - r.left) / Math.max(1, r.width))
					);
					return frac * barCycleSec;
				}
				function applyOffsetAt(clientX) {
					const it = loops.get(id);
					if (!it) return;
					it.offsetSec = pxToOffsetSec(clientX);
					updateHandleUI(it);
				}
				function onDown(e) {
					dragging = true;
					prog.setPointerCapture(e.pointerId);
					e.preventDefault();
					applyOffsetAt(e.clientX);
				}
				function onMove(e) {
					if (!dragging) return;
					applyOffsetAt(e.clientX);
				}
				function onUp(e) {
					if (!dragging) return;
					dragging = false;
					try {
						prog.releasePointerCapture(e.pointerId);
					} catch (_) {}
					const it = loops.get(id);
					if (!it) return;
					restartFromOffset(it); // audible commit
				}
				prog.addEventListener('pointerdown', onDown);
				prog.addEventListener('pointermove', onMove);
				prog.addEventListener('pointerup', onUp);
				prog.addEventListener('pointercancel', onUp);
				handle.addEventListener('pointerdown', onDown);

				// attach bar refs
				queueMicrotask(() => {
					const it = loops.get(id);
					if (it) {
						it.bar = { wrap: prog, fill, handle };
						updateHandleUI(it);
					}
				});

				return row;
			}

			function updateHandleUI(item) {
				if (!item || !item.bar || !barCycleSec) return;
				const frac = ((item.offsetSec || 0) % barCycleSec) / barCycleSec;
				item.bar.handle.style.left = `${frac * 100}%`;
			}
			function updateFillUI(item, now) {
				if (!item || !item.bar || !item.buffer || transportStartTime == null)
					return;
				const dur = item.buffer.duration || 0;
				if (dur <= 0 || barCycleSec <= 0) return;
				// position inside this track at absolute time "now"
				const off = (((item.offsetSec || 0) % dur) + dur) % dur;
				const posTrack = (((now - transportStartTime - off) % dur) + dur) % dur;
				const frac = Math.max(0, Math.min(1, posTrack / barCycleSec)); // scaled to longest
				item.bar.fill.style.width = `${frac * 100}%`;
			}

			/* ===== Solo helpers ===== */
			function toggleSolo(id) {
				const cur = loops.get(id);
				if (!cur) return;
				const enable = !cur.solo;
				for (const [, it] of loops) it.solo = enable ? it.id === id : false;
				updateSoloButtonsUI();
				updateAllGains();
			}
			function updateSoloButtonsUI() {
				for (const [, it] of loops) {
					const row = document.getElementById(it.id);
					if (!row) continue;
					const b = row.querySelector('.solo');
					if (!b) continue;
					b.classList.toggle('active', !!it.solo);
					b.setAttribute('aria-pressed', String(!!it.solo));
				}
			}

			/* ===== Remove loop ===== */
			function removeLoop(id) {
				const it = loops.get(id);
				if (!it) return;
				if (it.resyncTimer) {
					clearTimeout(it.resyncTimer);
					it.resyncTimer = null;
				}
				try {
					it.source.stop();
				} catch (_) {}
				try {
					it.source.disconnect();
				} catch (_) {}
				try {
					it.gainNode.disconnect();
				} catch (_) {}
				if (it.el && it.el.parentNode) it.el.parentNode.removeChild(it.el);
				const wasSolo = !!it.solo;
				loops.delete(id);
				if (loops.size === 0) {
					masterLenSec = null;
					transportStartTime = null;
					barCycleSec = 0;
				} else {
					recomputeBarCycle();
				}
				if (wasSolo) {
					updateSoloButtonsUI();
					updateAllGains();
				}
				setStatus('Loop removed.');
			}

			/* ===== Halt / Resume (fixed) ===== */
			function updateHaltButtonUI() {
				haltBtn.textContent =
					audioCtx && audioCtx.state === 'running'
						? '⏹ Stop Playback'
						: '▶ Resume Playback';
			}
			haltBtn.addEventListener('click', async () => {
				ensureAudio();
				try {
					if (audioCtx.state === 'running') {
						// fade then suspend (and freeze bars)
						masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
						await audioCtx.suspend();
						isPlaybackSuspended = true;
						frozenNow = audioCtx.currentTime;
						updateHaltButtonUI();
						setStatus('Playback suspended.');
					} else {
						// suspended -> resume and restore volume
						await audioCtx.resume();
						masterGain.gain.setTargetAtTime(1, audioCtx.currentTime, 0.01);
						isPlaybackSuspended = false;
						updateHaltButtonUI();
						setStatus('Playback resumed.');
					}
				} catch (e) {
					console.error(e);
				}
			});

			/* Important: DO NOT auto-resume the context while the user has explicitly suspended it. */
			/* We only help resume for recording start via startRecording(). */
			recToggleBtn.addEventListener('click', () => {
				toggleRecording();
			});

			window.addEventListener('beforeunload', () => {
				for (const [, it] of loops) {
					try {
						it.source.stop();
					} catch (_) {}
				}
				loops.clear();
				if (mixWavUrl) {
					URL.revokeObjectURL(mixWavUrl);
					mixWavUrl = null;
				}
			});

			/* ===== Mix Recorder ===== */
			function ensureMixStream() {
				if (!audioCtx) return;
				if (!mixDest) {
					mixDest = audioCtx.createMediaStreamDestination();
					masterGain.connect(mixDest);
				}
			}
			function bufferToInterleavedFloat32(buf) {
				const ch = buf.numberOfChannels | 0,
					frames = buf.length | 0;
				const out = new Float32Array(frames * ch);
				for (let i = 0; i < frames; i++) {
					for (let c = 0; c < ch; c++) {
						out[i * ch + c] = buf.getChannelData(c)[i] || 0;
					}
				}
				return out;
			}
			function floatTo16PCM(float32) {
				const dv = new DataView(new ArrayBuffer(float32.length * 2));
				let off = 0;
				for (let i = 0; i < float32.length; i++) {
					let s = Math.max(-1, Math.min(1, float32[i]));
					dv.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7fff, true);
					off += 2;
				}
				return dv.buffer;
			}
			function createWavFromBuffer(buf) {
				const inter = bufferToInterleavedFloat32(buf);
				const sr = buf.sampleRate | 0;
				const ch = buf.numberOfChannels | 0;
				const bps = 2,
					blockAlign = ch * bps,
					byteRate = sr * blockAlign,
					dataBytes = inter.length * bps;
				const header = new ArrayBuffer(44);
				const dv = new DataView(header);
				let p = 0;
				const ws = (s) => {
					for (let i = 0; i < s.length; i++) dv.setUint8(p++, s.charCodeAt(i));
				};
				const w32 = (v) => {
					dv.setUint32(p, v, true);
					p += 4;
				};
				const w16 = (v) => {
					dv.setUint16(p, v, true);
					p += 2;
				};
				ws('RIFF');
				w32(36 + dataBytes);
				ws('WAVE');
				ws('fmt ');
				w32(16);
				w16(1);
				w16(ch);
				w32(sr);
				w32(byteRate);
				w16(blockAlign);
				w16(bps * 8);
				ws('data');
				w32(dataBytes);
				const pcm = floatTo16PCM(inter);
				return new Blob([header, pcm], { type: 'audio/wav' });
			}
			function pickMixMimeType() {
				const c = [
					'audio/webm;codecs=opus',
					'audio/webm',
					'audio/ogg;codecs=opus',
					'audio/ogg',
				];
				for (const t of c) {
					if (
						window.MediaRecorder &&
						MediaRecorder.isTypeSupported &&
						MediaRecorder.isTypeSupported(t)
					)
						return t;
				}
				return '';
			}
			function updateMixRecUI(recording) {
				if (recording) {
					mixRecBtn.classList.remove('record');
					mixRecBtn.classList.add('stop');
					mixRecBtn.textContent = '■ Stop Mix';
					mixRecBtn.setAttribute('aria-pressed', 'true');
					mixDlBtn.disabled = true;
				} else {
					mixRecBtn.classList.remove('stop');
					mixRecBtn.classList.add('record');
					mixRecBtn.textContent = '⏺ Record Mix';
					mixRecBtn.setAttribute('aria-pressed', 'false');
				}
			}
			async function startMixRecording() {
				ensureAudio();
				await audioCtx.resume();
				ensureMixStream();
				try {
					const opts = {};
					const mt = pickMixMimeType();
					if (mt) opts.mimeType = mt;
					mixChunks = [];
					if (mixWavUrl) {
						URL.revokeObjectURL(mixWavUrl);
						mixWavUrl = null;
					}
					mixMR = new MediaRecorder(mixDest.stream, opts);
					mixMR.ondataavailable = (e) => {
						if (e.data && e.data.size > 0) mixChunks.push(e.data);
					};
					mixMR.onstop = async () => {
						try {
							const blob = new Blob(mixChunks, {
								type: mixMR.mimeType || 'audio/webm',
							});
							const ab = await blob.arrayBuffer();
							const buf = await decodeSafely(ab);
							const wav = createWavFromBuffer(buf);
							mixWavUrl = URL.createObjectURL(wav);
							mixDlBtn.disabled = false;
							setStatus(
								`Mix captured: ${buf.duration.toFixed(2)} s @ ${
									buf.sampleRate
								} Hz, ${buf.numberOfChannels} ch.`
							);
						} catch (err) {
							console.error(err);
							mixDlBtn.disabled = true;
							setStatus('Failed to build WAV from mix.');
						} finally {
							mixRecording = false;
							updateMixRecUI(false);
						}
					};
					mixMR.start();
					mixRecording = true;
					updateMixRecUI(true);
					setStatus('Recording mix… Press again to stop.');
				} catch (e) {
					console.error(e);
					setStatus('Could not start mix recording in this browser.');
					mixRecording = false;
					updateMixRecUI(false);
				}
			}
			async function stopMixRecording() {
				if (!mixRecording || !mixMR) return;
				try {
					mixMR.stop();
				} catch (_) {}
			}
			function toggleMixRecording() {
				if (!mixRecording) startMixRecording();
				else stopMixRecording();
			}
			mixRecBtn.addEventListener('click', toggleMixRecording);
			mixDlBtn.addEventListener('click', () => {
				if (!mixWavUrl) return;
				const a = document.createElement('a');
				a.href = mixWavUrl;
				a.download = `mix_${Date.now()}.wav`;
				document.body.appendChild(a);
				a.click();
				a.remove();
			});

			/* ===== UI ticker (freeze when suspended) ===== */
			function ensureUiTicker() {
				if (!uiRAF) uiRAF = requestAnimationFrame(updateBars);
			}
			function updateBars() {
				const running = !!audioCtx && audioCtx.state === 'running';
				const now = running ? audioCtx.currentTime : frozenNow;
				for (const [, it] of loops) {
					updateFillUI(it, now);
				}
				uiRAF = requestAnimationFrame(updateBars);
			}

			/* ===== Keyboard: Space (record), Shift+Space (halt/resume) ===== */
			function isInteractive(el) {
				if (!el) return false;
				const tag = el.tagName ? el.tagName.toLowerCase() : '';
				return (
					el.isContentEditable ||
					tag === 'input' ||
					tag === 'textarea' ||
					tag === 'select' ||
					tag === 'button' ||
					el.getAttribute('role') === 'button'
				);
			}
			window.addEventListener('keydown', (e) => {
				const isSpace = e.code === 'Space' || e.key === ' ';
				if (!isSpace) return;
				const el = document.activeElement;
				if (isInteractive(el)) return;
				e.preventDefault();
				if (e.shiftKey) {
					haltBtn.click();
				} else {
					toggleRecording();
				}
			});

			/* ===== Self-tests (console) ===== */
			(async function runSelfTests() {
				try {
					console.groupCollapsed('%cLooper self-tests', 'color:#5eead4');
					const tmp1 = new OfflineAudioContext(1, 62400, 48000);
					const buf1 = tmp1.createBuffer(1, 62400, 48000);
					const padded = padToMultiple(buf1, 0.5, tmp1);
					console.assert(padded.length === 72000, 'padToMultiple → 72000');

					transportStartTime = 100;
					masterLenSec = 0.5;
					let t = nextGridTime(100.1);
					console.assert(Math.abs(t - 100.5) < 1e-6, 'nextGridTime 100.5');
					t = nextGridTime(100.51);
					console.assert(Math.abs(t - 101.0) < 1e-6, 'nextGridTime 101.0');

					// offset mapping: when t == transportStartTime + offsetSec, phase should be 0
					const fake = { buffer: { duration: 2 }, offsetSec: 1.25 };
					transportStartTime = 0;
					let off = phaseOffsetAtTime(fake, 1.25);
					console.assert(Math.abs(off - 0) < 1e-6, 'phase zero at offset time');

					console.groupEnd();
				} catch (e) {
					console.error('Self-tests failed:', e);
				} finally {
					masterLenSec = null;
					transportStartTime = null;
					loops.clear();
					barCycleSec = 0;
				}
			})();

			/* ===== Add loop from mic ===== */
			async function handleRecordingStop() {
				try {
					const blob = new Blob(recordingChunks, {
						type: mediaRecorder.mimeType || 'audio/webm',
					});
					const ab = await blob.arrayBuffer();
					const buffer = await decodeSafely(ab);
					await addLoop(buffer);
				} catch (err) {
					console.error(err);
					setStatus('Could not decode audio. Please try another recording.');
				} finally {
					updateRecToggleUI(false);
				}
			}

			/* ===== Add loop row helpers ===== */
			function updateSoloButtonsUI() {
				for (const [, it] of loops) {
					const row = document.getElementById(it.id);
					if (!row) continue;
					const b = row.querySelector('.solo');
					if (b) {
						b.classList.toggle('active', !!it.solo);
						b.setAttribute('aria-pressed', String(!!it.solo));
					}
				}
			}
		</script>
	</body>
</html>
