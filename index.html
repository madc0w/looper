<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Simple Audio Looper</title>
		<style>
			:root {
				--bg: #0f1220;
				--panel: #171a2a;
				--accent: #5eead4;
				--text: #e6e8f1;
				--muted: #9aa0b4;
				--bar: #2a2f48;
				--barFill: #5eead4;
				--handle: #a8ffcb;
				--overlay: rgba(5, 7, 15, 0.65);
			}
			* {
				box-sizing: border-box;
			}
			body {
				margin: 0;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial,
					sans-serif;
				background: radial-gradient(
						1200px 600px at 50% -10%,
						#1d2140,
						#0b0e1a 70%
					),
					var(--bg);
				color: var(--text);
				min-height: 100dvh;
				display: grid;
				place-items: start center;
			}
			.wrap {
				width: min(1120px, 96vw);
				padding: 28px 16px 48px;
			}
			h1 {
				margin: 6px 0 18px;
				font-weight: 700;
				letter-spacing: 0.2px;
			}
			.panel {
				background: linear-gradient(180deg, #1a1e33, #14182a);
				border: 1px solid #242a42;
				border-radius: 16px;
				padding: 18px;
				box-shadow: 0 8px 28px rgba(0, 0, 0, 0.4);
			}
			.controls {
				display: grid;
				grid-template-columns: repeat(3, minmax(260px, 1fr));
				gap: 12px;
				align-items: center;
			}
			.btn {
				appearance: none;
				border: 0;
				border-radius: 12px;
				padding: 16px 18px;
				font-size: 18px;
				font-weight: 700;
				cursor: pointer;
				transition: transform 0.04s ease, box-shadow 0.2s ease,
					background 0.2s ease, opacity 0.2s ease;
				box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
				color: #0a1022;
				white-space: nowrap;
			}
			.btn:active {
				transform: translateY(1px);
			}
			.btn[disabled] {
				opacity: 0.5;
				cursor: not-allowed;
			}
			.btn.record {
				background: linear-gradient(180deg, #ff7a7a, #ff4747);
				color: #200;
			}
			.btn.stop {
				background: linear-gradient(180deg, #7af7d6, #3be7c3);
			}
			.btn.halt {
				background: linear-gradient(180deg, #9cc2ff, #6aa0ff);
			}
			.status {
				margin-top: 10px;
				color: var(--muted);
				font-size: 14px;
				min-height: 20px;
			}

			.samples {
				margin-top: 18px;
				display: grid;
				gap: 10px;
			}
			.sample {
				display: grid;
				grid-template-columns: 1fr minmax(260px, 34%) 42px 42px 42px 50px 50px 42px;
				gap: 10px;
				align-items: center;
				background: var(--panel);
				border: 1px solid #252a40;
				border-radius: 12px;
				padding: 10px 12px;
			}
			.sample .name {
				font-weight: 600;
				color: #dbe2ff;
				font-size: 14px;
				outline: none;
			}
			.sample .name[contenteditable='true'] {
				background: rgba(94, 234, 212, 0.08);
				border-radius: 6px;
				padding: 2px 4px;
			}
			.sample .info {
				color: #9aa0b4;
				font-size: 12px;
				margin-bottom: 16px;
			} /* keeps handle clear */

			.progWrap {
				display: grid;
				gap: 6px;
			}
			.prog {
				position: relative;
				height: 10px;
				background: var(--bar);
				border-radius: 6px;
				overflow: visible;
				user-select: none;
				touch-action: none;
			}
			.prog .fill {
				position: absolute;
				top: 0;
				height: 100%;
				left: 0;
				width: 0%;
				background: var(--barFill);
				opacity: 0.9;
			}
			.prog .handle {
				position: absolute;
				top: -14px;
				width: 14px;
				height: 32px;
				background: var(--handle);
				border-radius: 7px;
				box-shadow: 0 1px 4px rgba(0, 0, 0, 0.35),
					0 0 0 1px rgba(0, 0, 0, 0.25) inset;
				cursor: ew-resize;
				transform: translateX(-50%);
				z-index: 2;
			}

			.vcol {
				display: grid;
				gap: 6px;
			}
			.row {
				display: grid;
				grid-template-columns: minmax(70px, 90px) 1fr;
				gap: 8px;
				align-items: center;
			}
			.row label {
				color: #9aa0b4;
				font-size: 12px;
			}
			.row input[type='range'] {
				width: 100%;
				background: transparent;
				color: #e6e8f1;
				border: 0;
				padding: 0;
				accent-color: var(--accent);
			}
			input[type='range'] {
				width: 100%;
				accent-color: var(--accent);
			}

			.del,
			.mute,
			.solo,
			.play,
			.eqbtn,
			.fxbtn {
				border: 0;
				background: #2a2f48;
				color: #d7e3ff;
				border-radius: 10px;
				width: 42px;
				height: 42px;
				font-size: 18px;
				cursor: pointer;
				transition: background 0.2s ease, transform 0.04s ease;
			}
			.eqbtn,
			.fxbtn {
				width: 50px;
				font-size: 14px;
				font-weight: 700;
			}
			.del {
				color: #ffb4b4;
			}
			.del:hover,
			.mute:hover,
			.solo:hover,
			.play:hover,
			.eqbtn:hover,
			.fxbtn:hover {
				background: #353b5a;
			}
			.del:active,
			.mute:active,
			.solo:active,
			.play:active,
			.eqbtn:active,
			.fxbtn:active {
				transform: translateY(1px);
			}
			.mute.active {
				color: #ffd28b;
				background: #3b415f;
			}
			.solo.active {
				color: #a8ffcb;
				background: #3b415f;
			}

			@media (max-width: 700px) {
				.controls {
					grid-template-columns: 1fr;
				}
				.sample {
					grid-template-columns: 1fr 1fr 42px 42px 42px 50px 50px 42px;
				}
			}

			.scope {
				display: none;
				margin-top: 10px;
				background: #0a0d18;
				border: 1px solid #252a40;
				border-radius: 12px;
				width: 100%;
				height: 140px;
			}
			.scope.active {
				display: block;
			}

			.footer {
				margin-top: 18px;
				color: #9aa0b4;
				font-size: 12px;
				text-align: center;
			}

			/* Modal base */
			.modalBackdrop {
				position: fixed;
				inset: 0;
				background: var(--overlay);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 9999;
			}
			.modal {
				width: min(680px, 96vw);
				background: #121629;
				border: 1px solid #2a3258;
				border-radius: 14px;
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
				padding: 16px;
			}
			.modal h2 {
				margin: 0 0 10px;
				font-size: 18px;
			}
			.modal button.small {
				border: 0;
				border-radius: 8px;
				padding: 10px 12px;
				background: #2a2f48;
				color: #e6e8f1;
				cursor: pointer;
			}
			.modal button.small:hover {
				background: #353b5a;
			}
			.modal .actions {
				display: flex;
				gap: 10px;
				justify-content: flex-end;
				margin-top: 14px;
			}

			/* EQ Modal specifics */
			.modal .grid {
				display: grid;
				grid-template-columns: repeat(5, 1fr);
				gap: 14px;
			}
			.modal .band {
				background: #0f1324;
				border: 1px solid #273051;
				border-radius: 10px;
				padding: 12px;
				display: grid;
				grid-template-rows: auto 1fr auto;
				align-items: center;
				justify-items: center;
				min-height: 220px;
			}
			.modal .band h3 {
				margin: 0 0 6px;
				font-size: 13px;
				color: #cfe4ff;
				text-align: center;
			}
			.vslider {
				-webkit-appearance: slider-vertical;
				writing-mode: bt-lr;
				width: 18px;
				height: 160px;
				padding: 0;
				accent-color: var(--accent);
				background: transparent;
				border: 0;
			}
			.modal .value {
				font-size: 12px;
				color: var(--muted);
				text-align: center;
				margin-top: 6px;
			}

			/* FX Modal specifics */
			/* FX Modal specifics (closer sliders) */
			.fxlist {
				display: grid;
				grid-template-columns: auto 160px; /* label sized to content, slider fixed */
				column-gap: 10px;
				row-gap: 8px;
				align-items: center;
				justify-content: start;
			}
			.fxlist .rowfx {
				display: contents;
			}
			.fxlist label {
				display: flex;
				align-items: center;
				gap: 8px;
				font-size: 14px;
				color: #e6e8f1;
				white-space: nowrap; /* keep the label compact */
			}
			.fxlist input[type='checkbox'] {
				width: 16px;
				height: 16px;
				accent-color: var(--accent);
			}
			/* keep sliders compact so they stay close */
			.fxlist input[type='range'] {
				width: 160px;
				accent-color: var(--accent);
			}
			.fxlist .disabled {
				opacity: 0.6;
			}

			@media (max-width: 520px) {
				.fxlist {
					grid-template-columns: auto 120px;
				}
				.fxlist input[type='range'] {
					width: 120px;
				}
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<h1>Simple Audio Looper</h1>
			<div class="panel">
				<div class="controls">
					<button id="recToggleBtn" class="btn record" aria-pressed="false">
						‚óè Record
					</button>
					<button id="haltBtn" class="btn halt" disabled>
						‚èπ Stop Playback
					</button>
					<button id="mixRecBtn" class="btn record" aria-pressed="false">
						‚è∫ Record Mix
					</button>
				</div>
				<div id="status" class="status">Ready.</div>
				<canvas id="scope" class="scope" aria-hidden="true"></canvas>
				<div id="samples" class="samples" aria-live="polite"></div>
			</div>
			<div class="footer">
				Space: Mic Record ‚Ä¢ Shift+Space: Stop/Resume ‚Ä¢ Tip: adjust levels with
				the sliders; click ‚úï to remove a loop.
			</div>
		</div>

		<!-- EQ Modal -->
		<div
			id="eqBackdrop"
			class="modalBackdrop"
			role="dialog"
			aria-modal="true"
			aria-labelledby="eqTitle"
		>
			<div class="modal">
				<h2 id="eqTitle">EQ ‚Äî <span id="eqTrackName"></span></h2>
				<div class="grid">
					<div class="band">
						<h3>Low<br />(120 Hz)</h3>
						<input
							id="eqLow"
							class="vslider"
							type="range"
							min="-12"
							max="12"
							step="0.1"
							value="0"
						/>
						<div class="value"><span id="eqLowVal">0.0</span> dB</div>
					</div>
					<div class="band">
						<h3>Low-Mid<br />(350 Hz)</h3>
						<input
							id="eqLowMid"
							class="vslider"
							type="range"
							min="-12"
							max="12"
							step="0.1"
							value="0"
						/>
						<div class="value"><span id="eqLowMidVal">0.0</span> dB</div>
					</div>
					<div class="band">
						<h3>Mid<br />(1 kHz)</h3>
						<input
							id="eqMid"
							class="vslider"
							type="range"
							min="-12"
							max="12"
							step="0.1"
							value="0"
						/>
						<div class="value"><span id="eqMidVal">0.0</span> dB</div>
					</div>
					<div class="band">
						<h3>High-Mid<br />(3.5 kHz)</h3>
						<input
							id="eqHighMid"
							class="vslider"
							type="range"
							min="-12"
							max="12"
							step="0.1"
							value="0"
						/>
						<div class="value"><span id="eqHighMidVal">0.0</span> dB</div>
					</div>
					<div class="band">
						<h3>High<br />(8 kHz)</h3>
						<input
							id="eqHigh"
							class="vslider"
							type="range"
							min="-12"
							max="12"
							step="0.1"
							value="0"
						/>
						<div class="value"><span id="eqHighVal">0.0</span> dB</div>
					</div>
				</div>
				<div class="actions">
					<button id="eqReset" class="small">Reset</button>
					<button id="eqClose" class="small">Close</button>
				</div>
			</div>
		</div>

		<!-- FX Modal -->
		<div
			id="fxBackdrop"
			class="modalBackdrop"
			role="dialog"
			aria-modal="true"
			aria-labelledby="fxTitle"
		>
			<div class="modal">
				<h2 id="fxTitle">FX ‚Äî <span id="fxTrackName"></span></h2>
				<div class="fxlist">
					<!-- Reverse (toggle only) -->
					<div class="rowfx">
						<label
							><input id="fxReverse" type="checkbox" />Reverse (toggle)</label
						>
						<div class="disabled">‚Äî</div>
					</div>
					<!-- Echo -->
					<div class="rowfx">
						<label><input id="fxEcho" type="checkbox" />Echo</label>
						<input id="fxEchoWet" type="range" min="0" max="100" value="0" />
					</div>
					<!-- Reverb -->
					<div class="rowfx">
						<label><input id="fxReverb" type="checkbox" />Reverb</label>
						<input id="fxReverbWet" type="range" min="0" max="100" value="0" />
					</div>
					<!-- Chorus -->
					<div class="rowfx">
						<label><input id="fxChorus" type="checkbox" />Chorus</label>
						<input id="fxChorusWet" type="range" min="0" max="100" value="0" />
					</div>
					<!-- Flanger -->
					<div class="rowfx">
						<label><input id="fxFlanger" type="checkbox" />Flanger</label>
						<input id="fxFlangerWet" type="range" min="0" max="100" value="0" />
					</div>
					<!-- Phaser -->
					<div class="rowfx">
						<label><input id="fxPhaser" type="checkbox" />Phaser</label>
						<input id="fxPhaserWet" type="range" min="0" max="100" value="0" />
					</div>
					<!-- Compressor -->
					<div class="rowfx">
						<label><input id="fxComp" type="checkbox" />Compressor</label>
						<input id="fxCompWet" type="range" min="0" max="100" value="0" />
					</div>
					<!-- Gate / Expander -->
					<div class="rowfx">
						<label><input id="fxGate" type="checkbox" />Gate / Expander</label>
						<input id="fxGateWet" type="range" min="0" max="100" value="0" />
					</div>
				</div>
				<div class="actions">
					<button id="fxAllOff" class="small">All Off</button>
					<button id="fxClose" class="small">Close</button>
				</div>
			</div>
		</div>

		<script>
			'use strict';

			/* ========= Core audio ========= */
			let audioCtx = null,
				masterGain = null;
			let mediaStream = null,
				mediaRecorder = null,
				recordingChunks = [];
			let loopCounter = 0;

			/* Scope */
			let micSource = null,
				analyser = null,
				scopeRAF = null,
				scopeData = null,
				isDrawing = false;
			let recStartPerf = 0;

			/* Transport */
			let masterLenSec = null;
			let transportStartTime = null;

			/* Scheduler */
			let schedTimer = null;
			const SCHEDULE_AHEAD = 0.25;
			const SCHEDULE_INTERVAL = 50;

			/* Mix recording */
			let mixDest = null,
				mixMR = null,
				mixChunks = [],
				mixRecording = false;

			/** loop item:
			 * { id, displayName, buffer, revBuffer, gainNode, el, userGain, muted, solo,
			 *   offsetInBar, bar:{wrap,fill,handle},
			 *   periodBars, periodSec, nextStartTime, active:Set,
			 *   eq:{in, low, lowMid, mid, highMid, high, reset},
			 *   fx:{...} }
			 */
			const loops = new Map();

			/* ========= DOM ========= */
			const recToggleBtn = document.getElementById('recToggleBtn');
			const haltBtn = document.getElementById('haltBtn');
			const mixRecBtn = document.getElementById('mixRecBtn');
			const statusEl = document.getElementById('status');
			const samplesEl = document.getElementById('samples');
			const scopeCanvas = document.getElementById('scope');
			const scopeCtx = scopeCanvas.getContext('2d');

			const setStatus = (m) => (statusEl.textContent = m);

			function ensureAudio() {
				if (!audioCtx) {
					audioCtx = new (window.AudioContext || window.webkitAudioContext)();
					masterGain = audioCtx.createGain();
					masterGain.gain.value = 1.0;
					masterGain.connect(audioCtx.destination);
					haltBtn.disabled = false;
					updateHaltButtonUI();
				}
			}

			/* ========= Mic recording ========= */
			async function getMicStream() {
				if (mediaStream && mediaStream.active) return mediaStream;
				mediaStream = await navigator.mediaDevices.getUserMedia({
					audio: {
						echoCancellation: false,
						noiseSuppression: false,
						autoGainControl: false,
					},
					video: false,
				});
				return mediaStream;
			}
			function pickMimeType() {
				const c = [
					'audio/webm;codecs=opus',
					'audio/ogg;codecs=opus',
					'audio/webm',
					'audio/ogg',
				];
				for (const t of c) {
					if (
						window.MediaRecorder &&
						MediaRecorder.isTypeSupported &&
						MediaRecorder.isTypeSupported(t)
					)
						return t;
				}
				return '';
			}
			function decodeSafely(ab) {
				const copy = ab.slice(0);
				return new Promise((res, rej) =>
					audioCtx.decodeAudioData(copy, res, rej)
				);
			}

			/* ========= Oscilloscope ========= */
			function ensureAnalyser(stream) {
				if (!micSource) {
					micSource = audioCtx.createMediaStreamSource(stream);
					analyser = audioCtx.createAnalyser();
					analyser.fftSize = 2048;
					analyser.smoothingTimeConstant = 0.85;
					micSource.connect(analyser);
					scopeData = new Uint8Array(analyser.frequencyBinCount);
				}
			}
			function startScope() {
				if (!analyser) return;
				recStartPerf = performance.now();
				isDrawing = true;
				scopeCanvas.classList.add('active');
				scopeCanvas.setAttribute('aria-hidden', 'false');
				drawScope();
			}
			function stopScope() {
				isDrawing = false;
				if (scopeRAF) {
					cancelAnimationFrame(scopeRAF);
					scopeRAF = null;
				}
				try {
					scopeCtx.clearRect(0, 0, scopeCanvas.width, scopeCanvas.height);
				} catch (_) {}
				scopeCanvas.classList.remove('active');
				scopeCanvas.setAttribute('aria-hidden', 'true');
			}
			function fmtTime(secs) {
				secs = Math.max(0, secs || 0);
				const m = Math.floor(secs / 60),
					s = Math.floor(secs % 60),
					d = Math.floor((secs - Math.floor(secs)) * 10);
				return `${m}:${String(s).padStart(2, '0')}.${d}`;
			}
			function drawScope() {
				if (!isDrawing || !analyser) return;
				const dpr = window.devicePixelRatio || 1,
					cssW = scopeCanvas.clientWidth || 600,
					cssH = scopeCanvas.clientHeight || 140;
				if (
					scopeCanvas.width !== Math.floor(cssW * dpr) ||
					scopeCanvas.height !== Math.floor(cssH * dpr)
				) {
					scopeCanvas.width = Math.floor(cssW * dpr);
					scopeCanvas.height = Math.floor(cssH * dpr);
					scopeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
				}
				analyser.getByteTimeDomainData(scopeData);
				scopeCtx.clearRect(0, 0, cssW, cssH);
				scopeCtx.beginPath();
				const mid = cssH / 2,
					step = cssW / scopeData.length;
				for (let i = 0; i < scopeData.length; i++) {
					const v = (scopeData[i] - 128) / 128;
					const x = i * step;
					const y = mid + v * (cssH * 0.45);
					if (i === 0) scopeCtx.moveTo(x, y);
					else scopeCtx.lineTo(x, y);
				}
				scopeCtx.lineWidth = 2;
				scopeCtx.strokeStyle = '#79ffe1';
				scopeCtx.stroke();
				if (mediaRecorder && mediaRecorder.state === 'recording') {
					const elapsed = (performance.now() - recStartPerf) / 1000;
					const text = `REC ${fmtTime(elapsed)}`,
						pad = 6,
						h = 22;
					scopeCtx.font = '13px system-ui,-apple-system,Segoe UI,Roboto,Arial';
					const w = Math.ceil(scopeCtx.measureText(text).width) + pad * 2;
					scopeCtx.fillStyle = 'rgba(0,0,0,0.45)';
					scopeCtx.fillRect(cssW - w - 8, 8, w, h);
					scopeCtx.fillStyle = '#e6e8f1';
					scopeCtx.fillText(text, cssW - w - 8 + pad, 8 + 15);
				}
				scopeRAF = requestAnimationFrame(drawScope);
			}
			window.addEventListener('resize', () => {
				if (scopeCanvas.classList.contains('active')) drawScope();
			});

			/* ========= Solo / mute ========= */
			function anySoloActive() {
				for (const [, it] of loops) {
					if (it.solo) return true;
				}
				return false;
			}
			function effectiveGain(g, muted, solo, anySolo) {
				if (anySolo) return solo ? g : 0;
				return muted ? 0 : g;
			}
			function applyGain(it) {
				if (!it || !it.gainNode) return;
				const ug = it.userGain ?? 1;
				it.gainNode.gain.value = effectiveGain(
					ug,
					!!it.muted,
					!!it.solo,
					anySoloActive()
				);
			}
			function updateAllGains() {
				for (const [, it] of loops) applyGain(it);
			}

			/* ========= Helpers ========= */
			function padToMultiple(buffer, baseSec, ctx) {
				const rate = buffer.sampleRate | 0;
				const baseFrames = Math.max(1, Math.round(baseSec * rate));
				const cur = buffer.length | 0;
				const multiple = Math.max(1, Math.ceil(cur / baseFrames));
				const newLen = multiple * baseFrames;
				if (newLen === cur) return buffer;
				const out = ctx.createBuffer(buffer.numberOfChannels, newLen, rate);
				for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
					const src = buffer.getChannelData(ch),
						dst = out.getChannelData(ch);
					let pos = 0;
					while (pos < newLen) {
						const n = Math.min(src.length, newLen - pos);
						dst.set(src.subarray(0, n), pos);
						pos += n;
					}
				}
				return out;
			}
			async function resampleToContext(buffer, targetRate) {
				if (!buffer || buffer.sampleRate === targetRate) return buffer;
				const off = new OfflineAudioContext(
					buffer.numberOfChannels,
					Math.ceil(buffer.duration * targetRate),
					targetRate
				);
				const s = off.createBufferSource();
				s.buffer = buffer;
				s.connect(off.destination);
				s.start(0);
				return await off.startRendering();
			}
			function reverseAudioBuffer(buf) {
				const out = audioCtx.createBuffer(
					buf.numberOfChannels,
					buf.length,
					buf.sampleRate
				);
				for (let ch = 0; ch < buf.numberOfChannels; ch++) {
					const src = buf.getChannelData(ch),
						dst = out.getChannelData(ch);
					for (let i = 0, j = src.length - 1; i < src.length; i++, j--)
						dst[i] = src[j];
				}
				return out;
			}
			function firstStartAfter(now, item) {
				const anchor = transportStartTime + item.offsetInBar;
				if (now <= anchor + 0.01) return anchor;
				const k = Math.ceil((now - anchor) / item.periodSec);
				return anchor + k * item.periodSec;
			}

			/* ========= 5-band EQ ========= */
			function createEqFor(item) {
				const eqIn = audioCtx.createGain();
				const low = audioCtx.createBiquadFilter();
				low.type = 'lowshelf';
				low.frequency.value = 120;
				low.gain.value = 0;
				const lowMid = audioCtx.createBiquadFilter();
				lowMid.type = 'peaking';
				lowMid.frequency.value = 350;
				lowMid.Q.value = 1.0;
				lowMid.gain.value = 0;
				const mid = audioCtx.createBiquadFilter();
				mid.type = 'peaking';
				mid.frequency.value = 1000;
				mid.Q.value = 1.0;
				mid.gain.value = 0;
				const highMid = audioCtx.createBiquadFilter();
				highMid.type = 'peaking';
				highMid.frequency.value = 3500;
				highMid.Q.value = 1.0;
				highMid.gain.value = 0;
				const high = audioCtx.createBiquadFilter();
				high.type = 'highshelf';
				high.frequency.value = 8000;
				high.gain.value = 0;
				eqIn.connect(low);
				low.connect(lowMid);
				lowMid.connect(mid);
				mid.connect(highMid);
				highMid.connect(high);
				high.connect(item.gainNode);
				return {
					in: eqIn,
					low,
					lowMid,
					mid,
					highMid,
					high,
					reset: () => {
						low.gain.value = 0;
						lowMid.gain.value = 0;
						mid.gain.value = 0;
						highMid.gain.value = 0;
						high.gain.value = 0;
					},
				};
			}

			/* ========= FX (multi with per-FX wet) ========= */
			let gateModuleLoaded = false;
			async function ensureGateWorklet() {
				if (gateModuleLoaded) return;
				const code = `
          class GateExpanderProcessor extends AudioWorkletProcessor {
            static get parameterDescriptors() {
              return [
                {name:'thresholdDb', defaultValue:-50, minValue:-100, maxValue:0},
                {name:'ratio', defaultValue:2.0, minValue:1.0, maxValue:20.0},
                {name:'attack', defaultValue:0.01, minValue:0, maxValue:1},
                {name:'release', defaultValue:0.15, minValue:0, maxValue:1},
                {name:'floorDb', defaultValue:-60, minValue:-100, maxValue:0}
              ];
            }
            constructor(){ super(); this.env=0; this.sr=sampleRate; }
            dbToLin(db){ return Math.pow(10, db/20); }
            process(inputs, outputs, params){
              const input=inputs[0], output=outputs[0];
              if (!input || input.length===0) return true;
              const thDb=params.thresholdDb[0], ratio=params.ratio[0];
              const atk=params.attack[0], rel=params.release[0];
              const floorLin=this.dbToLin(params.floorDb[0]);
              const aA=Math.exp(-1/(this.sr*Math.max(1e-4,atk)));
              const aR=Math.exp(-1/(this.sr*Math.max(1e-4,rel)));
              for (let ch=0; ch<output.length; ch++){
                const inp=input[ch] || input[0], out=output[ch];
                if (!inp){ out.fill(0); continue; }
                for (let i=0;i<inp.length;i++){
                  const x=inp[i];
                  const rect=Math.abs(x);
                  const a = rect>this.env ? aA : aR;
                  this.env = a*this.env + (1-a)*rect;
                  const envDb = 20*Math.log10(this.env + 1e-12);
                  let gain=1.0;
                  if (envDb < thDb){
                    const diff = thDb - envDb;
                    const attDb = -diff*(ratio-1.0);
                    gain = Math.max(floorLin, this.dbToLin(attDb));
                  }
                  out[i]=x*gain;
                }
              }
              return true;
            }
          }
          registerProcessor('gate-expander', GateExpanderProcessor);
        `;
				const blob = new Blob([code], { type: 'application/javascript' });
				const url = URL.createObjectURL(blob);
				await audioCtx.audioWorklet.addModule(url);
				URL.revokeObjectURL(url);
				gateModuleLoaded = true;
			}

			function createFxFor(item, destNode) {
				// Dry to EQ input
				const dry = audioCtx.createGain();
				dry.gain.value = 1;
				dry.connect(destNode);

				// A single split point feeding all FX
				const fxIn = audioCtx.createGain();

				// Wet gains per FX, all go to EQ input (post-mix still passes through EQ)
				const wetEcho = audioCtx.createGain();
				wetEcho.gain.value = 0;
				wetEcho.connect(destNode);
				const wetReverb = audioCtx.createGain();
				wetReverb.gain.value = 0;
				wetReverb.connect(destNode);
				const wetChorus = audioCtx.createGain();
				wetChorus.gain.value = 0;
				wetChorus.connect(destNode);
				const wetFlanger = audioCtx.createGain();
				wetFlanger.gain.value = 0;
				wetFlanger.connect(destNode);
				const wetPhaser = audioCtx.createGain();
				wetPhaser.gain.value = 0;
				wetPhaser.connect(destNode);
				const wetComp = audioCtx.createGain();
				wetComp.gain.value = 0;
				wetComp.connect(destNode);
				const wetGate = audioCtx.createGain();
				wetGate.gain.value = 0;
				wetGate.connect(destNode);

				// Echo
				const delay = audioCtx.createDelay(1.0);
				delay.delayTime.value = 0.25;
				const fb = audioCtx.createGain();
				fb.gain.value = 0.35;
				fxIn.connect(delay);
				delay.connect(fb);
				fb.connect(delay);

				// Reverb
				const conv = audioCtx.createConvolver();
				conv.normalize = true;
				conv.buffer = (function genIR(ctx, seconds = 2.2, decay = 2.6) {
					const rate = ctx.sampleRate | 0,
						len = Math.max(1, Math.floor(seconds * rate));
					const buf = ctx.createBuffer(2, len, rate);
					for (let ch = 0; ch < 2; ch++) {
						const d = buf.getChannelData(ch);
						for (let i = 0; i < len; i++) {
							const t = i / len;
							d[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
						}
					}
					return buf;
				})(audioCtx);

				// Chorus
				const chorusDelay = audioCtx.createDelay(0.05);
				chorusDelay.delayTime.value = 0.015;
				const chorusLFO = audioCtx.createOscillator();
				chorusLFO.type = 'sine';
				chorusLFO.frequency.value = 1.2;
				const chorusDepth = audioCtx.createGain();
				chorusDepth.gain.value = 0.004;
				chorusLFO.connect(chorusDepth).connect(chorusDelay.delayTime);
				chorusLFO.start();
				fxIn.connect(chorusDelay);

				// Flanger
				const flangerDelay = audioCtx.createDelay(0.01);
				flangerDelay.delayTime.value = 0.002;
				const flangerLFO = audioCtx.createOscillator();
				flangerLFO.type = 'sine';
				flangerLFO.frequency.value = 0.25;
				const flangerDepth = audioCtx.createGain();
				flangerDepth.gain.value = 0.001;
				flangerLFO.connect(flangerDepth).connect(flangerDelay.delayTime);
				flangerLFO.start();
				const flangerFB = audioCtx.createGain();
				flangerFB.gain.value = 0.5;
				fxIn.connect(flangerDelay);
				flangerDelay.connect(flangerFB);
				flangerFB.connect(flangerDelay);

				// Phaser
				const ap1 = audioCtx.createBiquadFilter();
				ap1.type = 'allpass';
				ap1.frequency.value = 700;
				const ap2 = audioCtx.createBiquadFilter();
				ap2.type = 'allpass';
				ap2.frequency.value = 1000;
				const ap3 = audioCtx.createBiquadFilter();
				ap3.type = 'allpass';
				ap3.frequency.value = 1400;
				const ap4 = audioCtx.createBiquadFilter();
				ap4.type = 'allpass';
				ap4.frequency.value = 2000;
				fxIn.connect(ap1);
				ap1.connect(ap2);
				ap2.connect(ap3);
				ap3.connect(ap4);
				const phaserOut = ap4;
				const phLFO = audioCtx.createOscillator();
				phLFO.type = 'sine';
				phLFO.frequency.value = 0.5;
				const phDepth = audioCtx.createGain();
				phDepth.gain.value = 800;
				phLFO.connect(phDepth);
				phDepth.connect(ap1.frequency);
				phDepth.connect(ap2.frequency);
				phDepth.connect(ap3.frequency);
				phDepth.connect(ap4.frequency);
				const phBias = audioCtx.createConstantSource();
				phBias.offset.value = 0;
				phBias.start();
				phLFO.start();

				// Compressor
				const comp = audioCtx.createDynamicsCompressor();
				comp.threshold.value = -24;
				comp.ratio.value = 3;
				comp.attack.value = 0.01;
				comp.release.value = 0.18;
				comp.knee.value = 30;
				fxIn.connect(comp);

				// Gate / Expander (lazy)
				let gateNode = null;
				async function ensureGateNode() {
					if (!gateNode) {
						await ensureGateWorklet();
						gateNode = new AudioWorkletNode(audioCtx, 'gate-expander');
						gateNode.parameters
							.get('thresholdDb')
							.setValueAtTime(-50, audioCtx.currentTime);
						gateNode.parameters
							.get('ratio')
							.setValueAtTime(2.0, audioCtx.currentTime);
						gateNode.parameters
							.get('attack')
							.setValueAtTime(0.01, audioCtx.currentTime);
						gateNode.parameters
							.get('release')
							.setValueAtTime(0.15, audioCtx.currentTime);
						gateNode.parameters
							.get('floorDb')
							.setValueAtTime(-60, audioCtx.currentTime);
						fxIn.connect(gateNode);
					}
				}

				// Connect helpers
				const connect = (node, wet) => {
					try {
						node.connect(wet);
					} catch (_) {}
				};
				const disconnect = (node, wet) => {
					try {
						node.disconnect(wet);
					} catch (_) {}
				};

				const state = {
					reverse: false,
					echo: { enabled: false, wet: 0 },
					reverb: { enabled: false, wet: 0 },
					chorus: { enabled: false, wet: 0 },
					flanger: { enabled: false, wet: 0 },
					phaser: { enabled: false, wet: 0 },
					comp: { enabled: false, wet: 0 },
					gate: { enabled: false, wet: 0 },
				};

				const api = {
					dry,
					fxIn,
					// endpoints
					wet: {
						echo: wetEcho,
						reverb: wetReverb,
						chorus: wetChorus,
						flanger: wetFlanger,
						phaser: wetPhaser,
						comp: wetComp,
						gate: wetGate,
					},
					// nodes
					nodes: {
						delay,
						conv,
						chorusDelay,
						flangerDelay,
						phaserOut,
						comp,
						fb,
						flangerFB,
					},
					osc: { chorusLFO, flangerLFO, phLFO, phDepth },
					isReverse: false,
					async setEnabled(key, on) {
						if (key === 'reverse') {
							this.isReverse = !!on;
							state.reverse = !!on;
							return;
						}
						const map = {
							echo: [delay, wetEcho],
							reverb: [conv, wetReverb],
							chorus: [chorusDelay, wetChorus],
							flanger: [flangerDelay, wetFlanger],
							phaser: [phaserOut, wetPhaser],
							comp: [comp, wetComp],
							gate: ['gate', wetGate],
						};
						if (!(key in map)) return;
						if (key === 'gate') {
							if (on) {
								await ensureGateNode();
								connect(gateNode, wetGate);
							} else {
								if (gateNode) disconnect(gateNode, wetGate);
							}
							state.gate.enabled = !!on;
							return;
						}
						const [node, wet] = map[key];
						if (on) connect(node, wet);
						else disconnect(node, wet);
						state[key].enabled = !!on;
					},
					setWet(key, v) {
						const g = Math.max(0, Math.min(1, v));
						const map = {
							echo: wetEcho,
							reverb: wetReverb,
							chorus: wetChorus,
							flanger: wetFlanger,
							phaser: wetPhaser,
							comp: wetComp,
							gate: wetGate,
						};
						if (!map[key]) return;
						map[key].gain.value = g;
						state[key].wet = g;
					},
					getState() {
						return JSON.parse(JSON.stringify(state));
					},
				};
				return api;
			}

			/* ========= Scheduler ========= */
			function startScheduler() {
				if (!schedTimer)
					schedTimer = setInterval(schedulerTick, SCHEDULE_INTERVAL);
			}
			function stopScheduler() {
				if (schedTimer) {
					clearInterval(schedTimer);
					schedTimer = null;
				}
			}

			function startOneShot(item, when, startOffset, dur) {
				const src = audioCtx.createBufferSource();

				let buf = item.buffer,
					offset = startOffset,
					seg = dur;
				if (item.fx && item.fx.isReverse) {
					if (!item.revBuffer || item.revBuffer.length !== item.buffer.length) {
						item.revBuffer = reverseAudioBuffer(item.buffer);
					}
					buf = item.revBuffer;
					offset = Math.max(0, buf.duration - (startOffset + dur));
					seg = Math.max(0.001, Math.min(dur, buf.duration - offset));
				} else {
					offset = Math.min(startOffset, item.buffer.duration - 0.001);
					seg = Math.max(0.001, Math.min(dur, item.buffer.duration - offset));
				}

				src.buffer = buf;
				src.loop = false;
				// Split to dry and FX input (both feed EQ input downstream)
				src.connect(item.fx.dry);
				src.connect(item.fx.fxIn);
				src.start(when, offset, seg);
				item.active.add(src);
				src.onended = () => {
					item.active.delete(src);
				};
			}

			function schedulerTick() {
				if (
					!audioCtx ||
					audioCtx.state !== 'running' ||
					transportStartTime == null
				)
					return;
				const now = audioCtx.currentTime,
					horizon = now + SCHEDULE_AHEAD;
				for (const [, item] of loops) {
					if (item.nextStartTime == null)
						item.nextStartTime = firstStartAfter(now, item);
					while (item.nextStartTime < horizon) {
						const startOff = item.offsetInBar;
						const dur = item.periodSec - item.offsetInBar; // truncate from head by offset
						startOneShot(item, item.nextStartTime, startOff, dur);
						item.nextStartTime += item.periodSec;
					}
				}
			}

			/* ========= Loop creation ========= */
			function makeLoop(buffer) {
				const id = `loop-${++loopCounter}`;
				const gainNode = audioCtx.createGain();
				gainNode.gain.value = 1.0;
				gainNode.connect(masterGain);
				const el = renderSampleItem({ id, duration: buffer.duration });
				return {
					id,
					displayName: `Sample ${id.split('-')[1]}`,
					buffer,
					revBuffer: null,
					gainNode,
					el,
					userGain: 1.0,
					muted: false,
					solo: false,
					offsetInBar: 0,
					bar: null,
					periodBars: 1,
					periodSec: buffer.duration,
					nextStartTime: null,
					active: new Set(),
					eq: null,
					fx: null,
				};
			}

			async function addLoop(buffer) {
				ensureAudio();
				buffer = await resampleToContext(buffer, audioCtx.sampleRate);

				if (masterLenSec == null) {
					masterLenSec = buffer.duration;
					buffer = padToMultiple(buffer, masterLenSec, audioCtx);
					transportStartTime = audioCtx.currentTime + 0.25;
				} else {
					buffer = padToMultiple(buffer, masterLenSec, audioCtx);
				}

				const item = makeLoop(buffer);
				item.buffer = buffer;
				item.periodBars = Math.max(
					1,
					Math.round(buffer.duration / masterLenSec)
				);
				item.periodSec = item.periodBars * masterLenSec;

				item.eq = createEqFor(item);
				item.fx = createFxFor(item, item.eq.in);

				loops.set(item.id, item);

				item.nextStartTime = firstStartAfter(audioCtx.currentTime, item);
				startScheduler();

				setStatus('Loop added. It will align to the master bar.');
				updateSoloButtonsUI();
				updateAllGains();
			}

			/* ========= Row UI ========= */
			function renderSampleItem({ id, duration }) {
				const row = document.createElement('div');
				row.className = 'sample';
				row.id = id;

				const name = document.createElement('div');
				name.className = 'name';
				name.textContent = `Sample ${id.split('-')[1]}`;
				name.title = 'Click to rename. Press Enter to commit.';
				name.tabIndex = 0;

				const info = document.createElement('div');
				info.className = 'info';
				info.textContent = `${duration.toFixed(2)} s loop`;

				const progWrap = document.createElement('div');
				progWrap.className = 'progWrap';
				const prog = document.createElement('div');
				prog.className = 'prog';
				prog.setAttribute('aria-label', 'Time shift / progress');
				prog.tabIndex = 0;
				const fill = document.createElement('div');
				fill.className = 'fill';
				const handle = document.createElement('div');
				handle.className = 'handle';
				prog.appendChild(fill);
				prog.appendChild(handle);
				progWrap.appendChild(prog);

				const labelCol = document.createElement('div');
				labelCol.appendChild(name);
				labelCol.appendChild(info);
				labelCol.appendChild(progWrap);

				const vcol = document.createElement('div');
				vcol.className = 'vcol';
				const levelRow = document.createElement('div');
				levelRow.className = 'row';
				const levelLabel = document.createElement('label');
				levelLabel.textContent = 'Level';
				const levelSlider = document.createElement('input');
				levelSlider.type = 'range';
				levelSlider.min = '0';
				levelSlider.max = '100';
				levelSlider.value = '100';
				levelSlider.setAttribute('aria-label', 'Level');
				levelRow.appendChild(levelLabel);
				levelRow.appendChild(levelSlider);
				vcol.appendChild(levelRow);

				const play = document.createElement('button');
				play.className = 'play';
				play.title = 'Play now';
				play.setAttribute('aria-label', 'Play now');
				play.textContent = '‚ñ∂';
				const mute = document.createElement('button');
				mute.className = 'mute';
				mute.title = 'Mute/unmute';
				mute.setAttribute('aria-pressed', 'false');
				mute.textContent = 'üîà';
				const solo = document.createElement('button');
				solo.className = 'solo';
				solo.title = 'Solo';
				solo.setAttribute('aria-pressed', 'false');
				solo.textContent = 'üéß';
				const fxBtn = document.createElement('button');
				fxBtn.className = 'fxbtn';
				fxBtn.title = 'FX';
				fxBtn.textContent = 'FX';
				const eqBtn = document.createElement('button');
				eqBtn.className = 'eqbtn';
				eqBtn.title = 'EQ';
				eqBtn.textContent = 'EQ';
				const del = document.createElement('button');
				del.className = 'del';
				del.title = 'Delete loop';
				del.setAttribute('aria-label', 'Delete loop');
				del.textContent = '‚úï';

				row.appendChild(labelCol);
				row.appendChild(vcol);
				row.appendChild(play);
				row.appendChild(mute);
				row.appendChild(solo);
				row.appendChild(fxBtn);
				row.appendChild(eqBtn);
				row.appendChild(del);
				samplesEl.appendChild(row);

				/* events */
				levelSlider.addEventListener('input', () => {
					const it = loops.get(id);
					if (it) {
						it.userGain = parseInt(levelSlider.value, 10) / 100;
						applyGain(it);
					}
				});

				mute.addEventListener('click', () => {
					const it = loops.get(id);
					if (!it) return;
					it.muted = !it.muted;
					mute.classList.toggle('active', it.muted);
					mute.setAttribute('aria-pressed', String(it.muted));
					mute.textContent = it.muted ? 'üîá' : 'üîà';
					updateAllGains();
				});
				solo.addEventListener('click', () => toggleSolo(id));
				del.addEventListener('click', () => removeLoop(id));

				// Play now (head-truncated slice), then re-align
				play.addEventListener('click', () => {
					const it = loops.get(id);
					if (!it || !audioCtx) return;
					for (const s of it.active) {
						try {
							s.stop(0);
						} catch (_) {}
					}
					it.active.clear();
					const now = audioCtx.currentTime;
					const next = firstStartAfter(now, it);
					const sliceDur = Math.max(0.01, next - now);
					const maxDur = Math.min(sliceDur, it.periodSec - it.offsetInBar);
					startOneShot(it, now + 0.01, it.offsetInBar, maxDur);
					it.nextStartTime = next;
				});

				// Time-shift handle
				function pxToOffset(clientX) {
					const it = loops.get(id);
					if (!it || masterLenSec == null) return 0;
					const r = prog.getBoundingClientRect();
					const frac = Math.min(
						1,
						Math.max(0, (clientX - r.left) / Math.max(1, r.width))
					);
					const desired = frac * it.periodSec;
					return desired % masterLenSec;
				}
				function setHandle(it) {
					if (!it || !it.bar) return;
					it.bar.handle.style.left = `${
						(it.offsetInBar / it.periodSec) * 100
					}%`;
				}
				function dragAt(clientX) {
					const it = loops.get(id);
					if (!it) return;
					it.offsetInBar = pxToOffset(clientX);
					setHandle(it);
					updateFillUI(it, audioCtx ? audioCtx.currentTime : 0);
				}
				let dragging = false;
				function onDown(e) {
					dragging = true;
					if (e.pointerId != null) prog.setPointerCapture(e.pointerId);
					e.preventDefault();
					dragAt(e.clientX);
				}
				function onMove(e) {
					if (!dragging) return;
					dragAt(e.clientX);
				}
				function onUp(e) {
					if (!dragging) return;
					dragging = false;
					try {
						if (e.pointerId != null) prog.releasePointerCapture(e.pointerId);
					} catch (_) {}
					const it = loops.get(id);
					if (!it || transportStartTime == null || !audioCtx) return;
					for (const s of it.active) {
						try {
							s.stop(0);
						} catch (_) {}
					}
					it.active.clear();
					it.nextStartTime = firstStartAfter(audioCtx.currentTime, it);
					setStatus(
						`Shifted ${getDisplayNameSafe(id)} to ${it.offsetInBar.toFixed(
							2
						)}s of the bar.`
					);
				}
				prog.addEventListener('pointerdown', onDown);
				prog.addEventListener('pointermove', onMove);
				prog.addEventListener('pointerup', onUp);
				prog.addEventListener('pointercancel', onUp);
				handle.addEventListener('pointerdown', onDown);
				prog.addEventListener('mousedown', (e) => {
					onDown(e);
					const mm = (ev) => onMove(ev);
					const mu = (ev) => {
						document.removeEventListener('mousemove', mm);
						document.removeEventListener('mouseup', mu);
						onUp(ev);
					};
					document.addEventListener('mousemove', mm);
					document.addEventListener('mouseup', mu, { once: true });
				});

				// Editable name
				function commitName() {
					const it = loops.get(id);
					if (!it) return;
					const text = (name.textContent || '').trim();
					const val = text.length ? text : it.displayName;
					it.displayName = val;
					name.textContent = val;
					name.contentEditable = 'false';
					if (eqCurrentId === id) eqTrackName.textContent = it.displayName;
					if (fxCurrentId === id) fxTrackName.textContent = it.displayName;
				}
				name.addEventListener('click', () => {
					name.contentEditable = 'true';
					const r = document.createRange();
					r.selectNodeContents(name);
					r.collapse(false);
					const sel = window.getSelection();
					sel.removeAllRanges();
					sel.addRange(r);
					name.focus();
				});
				name.addEventListener('keydown', (e) => {
					if (e.key === 'Enter') {
						e.preventDefault();
						commitName();
						name.blur();
					} else if (e.key === 'Escape') {
						e.preventDefault();
						const it = loops.get(id);
						if (it) {
							name.textContent = it.displayName;
						}
						name.contentEditable = 'false';
						name.blur();
					}
				});
				name.addEventListener('blur', commitName);

				// EQ & FX buttons
				eqBtn.addEventListener('click', () => openEqModal(id));
				fxBtn.addEventListener('click', () => openFxModal(id));

				queueMicrotask(() => {
					const it = loops.get(id);
					if (it) {
						it.bar = { wrap: prog, fill, handle };
						setHandle(it);
					}
				});

				return row;
			}

			/* ======= VISUAL PROGRESS ======= */
			function updateFillUI(it, now) {
				if (!it || !it.bar || transportStartTime == null) return;
				const leftFrac = it.offsetInBar / it.periodSec;
				const dur = it.periodSec - it.offsetInBar;

				const anchor = transportStartTime + it.offsetInBar;
				const k = Math.floor((now - anchor) / it.periodSec);
				const cycleStart = anchor + Math.max(0, k) * it.periodSec;

				const elapsed = Math.max(0, now - cycleStart);
				const prog = Math.min(elapsed, dur);

				it.bar.fill.style.left = `${leftFrac * 100}%`;
				it.bar.fill.style.width = `${(prog / it.periodSec) * 100}%`;
			}

			/* ========= Solo ========= */
			function toggleSolo(id) {
				const cur = loops.get(id);
				if (!cur) return;
				const enable = !cur.solo;
				for (const [, it] of loops) it.solo = enable ? it.id === id : false;
				updateSoloButtonsUI();
				updateAllGains();
			}
			function updateSoloButtonsUI() {
				for (const [, it] of loops) {
					const row = document.getElementById(it.id);
					if (!row) continue;
					const b = row.querySelector('.solo');
					if (!b) continue;
					b.classList.toggle('active', !!it.solo);
					b.setAttribute('aria-pressed', String(!!it.solo));
				}
			}

			/* ========= Remove ========= */
			function removeLoop(id) {
				const it = loops.get(id);
				if (!it) return;
				for (const s of it.active) {
					try {
						s.stop(0);
					} catch (_) {}
				}
				it.active.clear();
				try {
					it.gainNode.disconnect();
				} catch (_) {}
				if (it.el && it.el.parentNode) it.el.parentNode.removeChild(it.el);
				loops.delete(id);
				setStatus('Loop removed.');
			}

			/* ========= Halt / resume ========= */
			function updateHaltButtonUI() {
				haltBtn.textContent =
					audioCtx && audioCtx.state === 'running'
						? '‚èπ Stop Playback'
						: '‚ñ∂ Resume Playback';
			}
			haltBtn.addEventListener('click', async () => {
				ensureAudio();
				if (!transportStartTime) {
					setStatus('Nothing to play yet. Record a loop first.');
					return;
				}
				if (audioCtx.state === 'running') {
					masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
					await audioCtx.suspend();
					updateHaltButtonUI();
					setStatus('Playback suspended.');
				} else {
					await audioCtx.resume();
					for (const [, it] of loops) {
						it.nextStartTime = firstStartAfter(audioCtx.currentTime, it);
					}
					masterGain.gain.setTargetAtTime(1, audioCtx.currentTime, 0.01);
					updateHaltButtonUI();
					setStatus('Playback resumed.');
				}
			});

			/* ========= Mix recorder (auto WAV) ========= */
			function ensureMixStream() {
				if (!audioCtx) return;
				if (!mixDest) {
					mixDest = audioCtx.createMediaStreamDestination();
					masterGain.connect(mixDest);
				}
			}
			function bufferToInterleavedFloat32(buf) {
				const ch = buf.numberOfChannels | 0,
					frames = buf.length | 0;
				const out = new Float32Array(frames * ch);
				for (let i = 0; i < frames; i++)
					for (let c = 0; c < ch; c++)
						out[i * ch + c] = buf.getChannelData(c)[i] || 0;
				return out;
			}
			function floatTo16PCM(float32) {
				const dv = new DataView(new ArrayBuffer(float32.length * 2));
				let off = 0;
				for (let i = 0; i < float32.length; i++) {
					let s = Math.max(-1, Math.min(1, float32[i]));
					dv.setInt16(off, s < 0 ? s * 0x8000 : s * 0x7fff, true);
					off += 2;
				}
				return dv.buffer;
			}
			function createWavFromBuffer(buf) {
				const inter = bufferToInterleavedFloat32(buf);
				const sr = buf.sampleRate | 0;
				const ch = buf.numberOfChannels | 0;
				const bps = 2,
					blockAlign = ch * bps,
					byteRate = sr * blockAlign,
					dataBytes = inter.length * bps;
				const header = new ArrayBuffer(44);
				const dv = new DataView(header);
				let p = 0;
				const ws = (s) => {
					for (let i = 0; i < s.length; i++) dv.setUint8(p++, s.charCodeAt(i));
				};
				const w32 = (v) => {
					dv.setUint32(p, v, true);
					p += 4;
				};
				const w16 = (v) => {
					dv.setUint16(p, v, true);
					p += 2;
				};
				ws('RIFF');
				w32(36 + dataBytes);
				ws('WAVE');
				ws('fmt ');
				w32(16);
				w16(1);
				w16(ch);
				w32(sr);
				w32(byteRate);
				w16(blockAlign);
				w16(bps * 8);
				ws('data');
				w32(dataBytes);
				const pcm = floatTo16PCM(inter);
				return new Blob([header, pcm], { type: 'audio/wav' });
			}
			function pickMixMimeType() {
				const c = [
					'audio/webm;codecs=opus',
					'audio/webm',
					'audio/ogg;codecs=opus',
					'audio/ogg',
				];
				for (const t of c) {
					if (
						window.MediaRecorder &&
						MediaRecorder.isTypeSupported &&
						MediaRecorder.isTypeSupported(t)
					)
						return t;
				}
				return '';
			}
			function updateMixRecUI(rec) {
				if (rec) {
					mixRecBtn.classList.remove('record');
					mixRecBtn.classList.add('stop');
					mixRecBtn.textContent = '‚ñ† Stop Mix';
					mixRecBtn.setAttribute('aria-pressed', 'true');
				} else {
					mixRecBtn.classList.remove('stop');
					mixRecBtn.classList.add('record');
					mixRecBtn.textContent = '‚è∫ Record Mix';
					mixRecBtn.setAttribute('aria-pressed', 'false');
				}
			}
			async function startMixRecording() {
				ensureAudio();
				await audioCtx.resume();
				ensureMixStream();
				try {
					const opts = {},
						mt = pickMixMimeType();
					if (mt) opts.mimeType = mt;
					mixChunks = [];
					mixMR = new MediaRecorder(mixDest.stream, opts);
					mixMR.ondataavailable = (e) => {
						if (e.data && e.data.size > 0) mixChunks.push(e.data);
					};
					mixMR.onstop = async () => {
						try {
							const blob = new Blob(mixChunks, {
								type: mixMR.mimeType || 'audio/webm',
							});
							const ab = await blob.arrayBuffer();
							const buf = await decodeSafely(ab);
							const wav = createWavFromBuffer(buf);
							const url = URL.createObjectURL(wav);
							const a = document.createElement('a');
							a.href = url;
							a.download = `mix_${Date.now()}.wav`;
							document.body.appendChild(a);
							a.click();
							a.remove();
							setTimeout(() => URL.revokeObjectURL(url), 4000);
							setStatus(
								`Mix captured: ${buf.duration.toFixed(2)} s @ ${
									buf.sampleRate
								} Hz.`
							);
						} catch (err) {
							console.error(err);
							setStatus('Failed to build WAV from mix.');
						} finally {
							updateMixRecUI(false);
							mixRecording = false;
						}
					};
					mixMR.start();
					updateMixRecUI(true);
					mixRecording = true;
					setStatus('Recording mix‚Ä¶ Press again to stop (WAV auto-downloads).');
				} catch (e) {
					console.error(e);
					setStatus('Could not start mix recording in this browser.');
					updateMixRecUI(false);
					mixRecording = false;
				}
			}
			async function stopMixRecording() {
				if (mixRecording && mixMR) {
					try {
						mixMR.stop();
					} catch (_) {}
				}
			}
			function toggleMixRecording() {
				if (!mixRecording) startMixRecording();
				else stopMixRecording();
			}
			mixRecBtn.addEventListener('click', toggleMixRecording);

			/* ========= UI ticker ========= */
			let uiRAF = null;
			function ensureUiTicker() {
				if (!uiRAF) uiRAF = requestAnimationFrame(updateBars);
			}
			function updateBars() {
				const now = !audioCtx ? 0 : audioCtx.currentTime;
				for (const [, it] of loops) updateFillUI(it, now);
				uiRAF = requestAnimationFrame(updateBars);
			}
			ensureUiTicker();

			/* ========= Keyboard ========= */
			function isInteractive(el) {
				if (!el) return false;
				const t = el.tagName ? el.tagName.toLowerCase() : '';
				return (
					el.isContentEditable ||
					t === 'input' ||
					t === 'textarea' ||
					t === 'select' ||
					t === 'button' ||
					el.getAttribute('role') === 'button'
				);
			}
			window.addEventListener('keydown', (e) => {
				const isSpace = e.code === 'Space' || e.key === ' ';
				if (!isSpace) return;
				const el = document.activeElement;
				if (isInteractive(el)) return;
				e.preventDefault();
				if (e.shiftKey) haltBtn.click();
				else recToggleBtn.click();
			});

			/* ========= Record toggle ========= */
			function updateRecToggleUI(rec) {
				if (rec) {
					recToggleBtn.classList.remove('record');
					recToggleBtn.classList.add('stop');
					recToggleBtn.textContent = '‚ñ† Stop';
					recToggleBtn.setAttribute('aria-pressed', 'true');
				} else {
					recToggleBtn.classList.remove('stop');
					recToggleBtn.classList.add('record');
					recToggleBtn.textContent = '‚óè Record';
					recToggleBtn.setAttribute('aria-pressed', 'false');
				}
			}
			recToggleBtn.addEventListener('click', async () => {
				try {
					if (mediaRecorder && mediaRecorder.state === 'recording') {
						stopScope();
						mediaRecorder.stop();
						setStatus('Processing‚Ä¶');
						updateRecToggleUI(false);
					} else {
						ensureAudio();
						await audioCtx.resume();
						const stream = await getMicStream();
						ensureAnalyser(stream);
						startScope();
						const opts = {},
							mt = pickMimeType();
						if (mt) opts.mimeType = mt;
						mediaRecorder = new MediaRecorder(stream, opts);
						recordingChunks = [];
						mediaRecorder.ondataavailable = (e) => {
							if (e.data && e.data.size > 0) recordingChunks.push(e.data);
						};
						mediaRecorder.onstop = handleRecordingStop;
						mediaRecorder.start();
						updateRecToggleUI(true);
						setStatus('Recording‚Ä¶ Press again to stop.');
					}
				} catch (e) {
					console.error(e);
					setStatus('Recording is not supported in this browser.');
				}
			});
			window.addEventListener('beforeunload', () => {
				if (schedTimer) clearInterval(schedTimer);
				for (const [, it] of loops) {
					for (const s of it.active) {
						try {
							s.stop(0);
						} catch (_) {}
					}
				}
			});

			/* ========= Recorder stop ========= */
			async function handleRecordingStop() {
				try {
					const blob = new Blob(recordingChunks, {
						type: mediaRecorder.mimeType || 'audio/webm',
					});
					const ab = await blob.arrayBuffer();
					const buffer = await decodeSafely(ab);
					await addLoop(buffer);
				} catch (err) {
					console.error(err);
					setStatus('Could not decode audio. Please try another recording.');
				}
			}

			/* ========= Solo helpers ========= */
			function updateSoloButtonsUI() {
				for (const [, it] of loops) {
					const row = document.getElementById(it.id);
					if (!row) continue;
					const btn = row.querySelector('.solo');
					if (!btn) continue;
					btn.classList.toggle('active', !!it.solo);
					btn.setAttribute('aria-pressed', String(!!it.solo));
				}
			}
			function toggleSolo(id) {
				const current = loops.get(id);
				if (!current) return;
				const enable = !current.solo;
				for (const [, it] of loops) {
					it.solo = enable ? it.id === id : false;
				}
				updateSoloButtonsUI();
				updateAllGains();
			}

			/* ========= Name helpers ========= */
			function getDisplayNameSafe(id) {
				const it = loops.get(id);
				return it && it.displayName
					? it.displayName
					: `Sample ${id.split('-')[1]}`;
			}

			/* ========= EQ Modal wiring ========= */
			const eqBackdrop = document.getElementById('eqBackdrop');
			const eqTrackName = document.getElementById('eqTrackName');
			const eqLow = document.getElementById('eqLow');
			const eqLowMid = document.getElementById('eqLowMid');
			const eqMid = document.getElementById('eqMid');
			const eqHighMid = document.getElementById('eqHighMid');
			const eqHigh = document.getElementById('eqHigh');
			const eqLowVal = document.getElementById('eqLowVal');
			const eqLowMidVal = document.getElementById('eqLowMidVal');
			const eqMidVal = document.getElementById('eqMidVal');
			const eqHighMidVal = document.getElementById('eqHighMidVal');
			const eqHighVal = document.getElementById('eqHighVal');
			const eqClose = document.getElementById('eqClose');
			const eqReset = document.getElementById('eqReset');

			let eqCurrentId = null;

			function setEqSliderVals(item) {
				eqLow.value = item.eq.low.gain.value;
				eqLowMid.value = item.eq.lowMid.gain.value;
				eqMid.value = item.eq.mid.gain.value;
				eqHighMid.value = item.eq.highMid.gain.value;
				eqHigh.value = item.eq.high.gain.value;

				eqLowVal.textContent = (+eqLow.value).toFixed(1);
				eqLowMidVal.textContent = (+eqLowMid.value).toFixed(1);
				eqMidVal.textContent = (+eqMid.value).toFixed(1);
				eqHighMidVal.textContent = (+eqHighMid.value).toFixed(1);
				eqHighVal.textContent = (+eqHigh.value).toFixed(1);
			}

			function openEqModal(id) {
				const it = loops.get(id);
				if (!it) return;
				eqCurrentId = id;
				eqTrackName.textContent =
					it.displayName || `Sample ${id.split('-')[1]}`;
				setEqSliderVals(it);
				eqBackdrop.style.display = 'flex';
			}
			function closeEqModal() {
				eqBackdrop.style.display = 'none';
				eqCurrentId = null;
			}

			eqLow.addEventListener('input', () => {
				if (!eqCurrentId) return;
				const it = loops.get(eqCurrentId);
				if (!it) return;
				it.eq.low.gain.value = +eqLow.value;
				eqLowVal.textContent = (+eqLow.value).toFixed(1);
			});
			eqLowMid.addEventListener('input', () => {
				if (!eqCurrentId) return;
				const it = loops.get(eqCurrentId);
				if (!it) return;
				it.eq.lowMid.gain.value = +eqLowMid.value;
				eqLowMidVal.textContent = (+eqLowMid.value).toFixed(1);
			});
			eqMid.addEventListener('input', () => {
				if (!eqCurrentId) return;
				const it = loops.get(eqCurrentId);
				if (!it) return;
				it.eq.mid.gain.value = +eqMid.value;
				eqMidVal.textContent = (+eqMid.value).toFixed(1);
			});
			eqHighMid.addEventListener('input', () => {
				if (!eqCurrentId) return;
				const it = loops.get(eqCurrentId);
				if (!it) return;
				it.eq.highMid.gain.value = +eqHighMid.value;
				eqHighMidVal.textContent = (+eqHighMid.value).toFixed(1);
			});
			eqHigh.addEventListener('input', () => {
				if (!eqCurrentId) return;
				const it = loops.get(eqCurrentId);
				if (!it) return;
				it.eq.high.gain.value = +eqHigh.value;
				eqHighVal.textContent = (+eqHigh.value).toFixed(1);
			});

			eqReset.addEventListener('click', () => {
				if (!eqCurrentId) return;
				const it = loops.get(eqCurrentId);
				if (!it) return;
				it.eq.reset();
				setEqSliderVals(it);
			});
			eqClose.addEventListener('click', closeEqModal);
			eqBackdrop.addEventListener('click', (e) => {
				if (e.target === eqBackdrop) closeEqModal();
			});

			/* ========= FX Modal wiring ========= */
			const fxBackdrop = document.getElementById('fxBackdrop');
			const fxTrackName = document.getElementById('fxTrackName');

			const fxReverse = document.getElementById('fxReverse');

			const fxEcho = document.getElementById('fxEcho');
			const fxEchoWet = document.getElementById('fxEchoWet');

			const fxReverb = document.getElementById('fxReverb');
			const fxReverbWet = document.getElementById('fxReverbWet');

			const fxChorus = document.getElementById('fxChorus');
			const fxChorusWet = document.getElementById('fxChorusWet');

			const fxFlanger = document.getElementById('fxFlanger');
			const fxFlangerWet = document.getElementById('fxFlangerWet');

			const fxPhaser = document.getElementById('fxPhaser');
			const fxPhaserWet = document.getElementById('fxPhaserWet');

			const fxComp = document.getElementById('fxComp');
			const fxCompWet = document.getElementById('fxCompWet');

			const fxGate = document.getElementById('fxGate');
			const fxGateWet = document.getElementById('fxGateWet');

			const fxClose = document.getElementById('fxClose');
			const fxAllOff = document.getElementById('fxAllOff');

			let fxCurrentId = null;

			function setFxControlsFromState(item) {
				const st = item.fx.getState();
				fxReverse.checked = !!st.reverse;

				fxEcho.checked = !!st.echo.enabled;
				fxEchoWet.value = Math.round((st.echo.wet || 0) * 100);
				fxReverb.checked = !!st.reverb.enabled;
				fxReverbWet.value = Math.round((st.reverb.wet || 0) * 100);
				fxChorus.checked = !!st.chorus.enabled;
				fxChorusWet.value = Math.round((st.chorus.wet || 0) * 100);
				fxFlanger.checked = !!st.flanger.enabled;
				fxFlangerWet.value = Math.round((st.flanger.wet || 0) * 100);
				fxPhaser.checked = !!st.phaser.enabled;
				fxPhaserWet.value = Math.round((st.phaser.wet || 0) * 100);
				fxComp.checked = !!st.comp.enabled;
				fxCompWet.value = Math.round((st.comp.wet || 0) * 100);
				fxGate.checked = !!st.gate.enabled;
				fxGateWet.value = Math.round((st.gate.wet || 0) * 100);
			}

			function openFxModal(id) {
				const it = loops.get(id);
				if (!it) return;
				fxCurrentId = id;
				fxTrackName.textContent =
					it.displayName || `Sample ${id.split('-')[1]}`;
				setFxControlsFromState(it);
				fxBackdrop.style.display = 'flex';
			}
			function closeFxModal() {
				fxBackdrop.style.display = 'none';
				fxCurrentId = null;
			}

			async function bindFxCheckbox(cb, key) {
				cb.addEventListener('change', async () => {
					if (!fxCurrentId) return;
					const it = loops.get(fxCurrentId);
					if (!it) return;
					await it.fx.setEnabled(key, cb.checked);
					const pretty =
						key === 'gate'
							? 'Gate/Expander'
							: key === 'comp'
							? 'Compressor'
							: key[0].toUpperCase() + key.slice(1);
					setStatus(`${pretty} ${cb.checked ? 'enabled' : 'disabled'}.`);
				});
			}
			function bindFxWet(sl, key) {
				sl.addEventListener('input', () => {
					if (!fxCurrentId) return;
					const it = loops.get(fxCurrentId);
					if (!it) return;
					it.fx.setWet(key, parseInt(sl.value, 10) / 100);
				});
			}

			// Bind all
			bindFxCheckbox(fxReverse, 'reverse');

			bindFxCheckbox(fxEcho, 'echo');
			bindFxWet(fxEchoWet, 'echo');
			bindFxCheckbox(fxReverb, 'reverb');
			bindFxWet(fxReverbWet, 'reverb');
			bindFxCheckbox(fxChorus, 'chorus');
			bindFxWet(fxChorusWet, 'chorus');
			bindFxCheckbox(fxFlanger, 'flanger');
			bindFxWet(fxFlangerWet, 'flanger');
			bindFxCheckbox(fxPhaser, 'phaser');
			bindFxWet(fxPhaserWet, 'phaser');
			bindFxCheckbox(fxComp, 'comp');
			bindFxWet(fxCompWet, 'comp');
			bindFxCheckbox(fxGate, 'gate');
			bindFxWet(fxGateWet, 'gate');

			fxAllOff.addEventListener('click', async () => {
				if (!fxCurrentId) return;
				const it = loops.get(fxCurrentId);
				if (!it) return;
				const pairs = [
					[fxReverse, 'reverse', false],
					[fxEcho, 'echo', true],
					[fxReverb, 'reverb', true],
					[fxChorus, 'chorus', true],
					[fxFlanger, 'flanger', true],
					[fxPhaser, 'phaser', true],
					[fxComp, 'comp', true],
					[fxGate, 'gate', true],
				];
				for (const [cb, key, hasWet] of pairs) {
					cb.checked = false;
					await it.fx.setEnabled(key, false);
					if (hasWet) {
						it.fx.setWet(key, 0);
					}
				}
				setFxControlsFromState(it);
				setStatus('All FX disabled.');
			});
			fxClose.addEventListener('click', closeFxModal);
			fxBackdrop.addEventListener('click', (e) => {
				if (e.target === fxBackdrop) closeFxModal();
			});

			// Close modals on Esc
			window.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') {
					if (eqBackdrop.style.display === 'flex') closeEqModal();
					if (fxBackdrop.style.display === 'flex') closeFxModal();
				}
			});
		</script>
	</body>
</html>
